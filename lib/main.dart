// Dart Core
import 'dart:async';
import 'dart:io' show Platform;

// Flutter Core
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';

// Device & Network
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:network_info_plus/network_info_plus.dart';
import 'package:permission_handler/permission_handler.dart';

// Firebase
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'firebase_options.dart'; // generated by `flutterfire configure`

// Local notifications
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

/// ─────────────────────────────────────────────────────────────────────────────
/// CONFIG
/// ─────────────────────────────────────────────────────────────────────────────

const bool kUseFirebase = true;
const bool kUseFcm = true;

/// Your RTDB URL (same as ESP32 firmware)
const String kDatabaseUrl =
    'https://intellideskisannoying-default-rtdb.asia-southeast1.firebasedatabase.app';

// 10s vibration (milliseconds): wait 0ms, vibrate 10,000ms
final Int64List kVibrate10s = Int64List.fromList(<int>[0, 10000]);
const String kNotificationSound = 'alert';

// --- CUSTOM THEME COLORS (from your new design) ---
const Color kPrimaryBlue = Color(0xFF4A90E2);
const Color kBackgroundLight = Color(0xFFF7F9FC);
const Color kTextPrimaryLight = Color(0xFF1E293B);
const Color kBorderLight = Color(0xFFCBD5E1);

/// ─────────────────────────────────────────────────────────────────────────────
/// MODELS
/// ─────────────────────────────────────────────────────────────────────────────

class AppUser {
  final String uid;
  final String email;
  String get displayName => email.split('@')[0];
  AppUser({required this.uid, required this.email});
}

class Task {
  final String id;
  final String title;
  final DateTime? due;
  final bool done;
  const Task({
    required this.id,
    required this.title,
    this.due,
    this.done = false,
  });
  Task copyWith({String? title, DateTime? due, bool? done}) => Task(
        id: id,
        title: title ?? this.title,
        due: due ?? this.due,
        done: done ?? this.done,
      );
}

/// Model for an item the user has registered
class UserItem {
  final String macAddress; // This will be the document ID
  final String name;
  const UserItem({required this.macAddress, required this.name});
}

/// Combined model for display
class TrackableItem {
  final String id; // MAC Address
  final String name;
  final bool atHome; // Live status
  const TrackableItem({
    required this.id,
    required this.name,
    required this.atHome,
  });
}

class SensorData {
  final double? temperature;
  final double? humidity;
  final double? lightLux;

  const SensorData({this.temperature, this.humidity, this.lightLux});

  factory SensorData.fromMap(Map data) => SensorData(
        temperature: (data['temperature'] as num?)?.toDouble(),
        humidity: (data['humidity'] as num?)?.toDouble(),
        lightLux: (data['light_lux'] as num?)?.toDouble(),
      );
}

/// ─────────────────────────────────────────────────────────────────────────────
/// WIFI (phone) + left-home detection (Kept from original logic)
/// ─────────────────────────────────────────────────────────────────────────────
class HomeWifi {
  final String ssid;
  final String bssid;
  const HomeWifi({required this.ssid, required this.bssid});
}

bool _sameBssid(String? a, String? b) =>
    a != null && b != null && a.toUpperCase() == b.toUpperCase();

String? _cleanSsid(String? raw) {
  if (raw == null) return null;
  var s = raw.trim();
  if (s.isEmpty) return null;
  if (s.toLowerCase() == '<unknown ssid>') return null;
  if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
    s = s.substring(1, s.length - 1);
  }
  return s.isEmpty ? null : s;
}

final phoneWifiProvider = StreamProvider<HomeWifi?>((ref) async* {
  if (kIsWeb || !Platform.isAndroid) {
    yield null;
    return;
  }

  await Permission.locationWhenInUse.request();
  try {
    await Permission.nearbyWifiDevices.request();
  } catch (_) {}

  final connectivity = Connectivity();
  final info = NetworkInfo();

  yield* Stream.periodic(const Duration(seconds: 3), (_) async {
    try {
      final results = await connectivity.checkConnectivity();
      if (!results.contains(ConnectivityResult.wifi)) return null;
      final ssid = _cleanSsid(await info.getWifiName());
      final bssid = await info.getWifiBSSID();
      if (ssid == null || bssid == null) return null;
      return HomeWifi(ssid: ssid, bssid: bssid);
    } catch (_) {
      return null;
    }
  }).asyncMap((f) async => await f);
});

class EspWifi {
  final String ssid;
  final String bssid;
  const EspWifi({required this.ssid, required this.bssid});

  factory EspWifi.fromMap(Map m) => EspWifi(
        ssid: _cleanSsid(m['ssid'] as String?) ?? '',
        bssid: (m['bssid'] as String? ?? '').toUpperCase(),
      );
}

final espWifiProvider = StreamProvider<EspWifi?>((ref) {
  if (!kUseFirebase) return const Stream.empty();
  final refDb = _db.ref('/esp_wifi');
  return refDb.onValue.map((e) {
    final v = e.snapshot.value;
    if (v is Map) {
      try {
        final x = EspWifi.fromMap(v);
        if (x.bssid.isNotEmpty) return x;
      } catch (e) {
        debugPrint('ESP WiFi parse error: $e');
      }
    }
    return null;
  });
});

final atHomeNowProvider = Provider<bool?>((ref) {
  final phone = ref.watch(phoneWifiProvider).asData?.value;
  final esp = ref.watch(espWifiProvider).asData?.value;
  if (phone == null || esp == null) return null;
  return _sameBssid(phone.bssid, esp.bssid);
});

final leftHomeFromEspWifiProvider = StreamProvider<bool>((ref) {
  final c = StreamController<bool>.broadcast();
  bool? prev;
  ref.listen<bool?>(atHomeNowProvider, (_, cur) {
    if (prev == true && cur == false) c.add(true);
    prev = cur;
  });
  ref.onDispose(c.close);
  return c.stream;
});

final leftHomeAnyProvider = StreamProvider<bool>((ref) {
  final controller = StreamController<bool>.broadcast();
  ref.listen<AsyncValue<bool>>(leftHomeFromEspWifiProvider, (_, next) {
    next.whenData((value) {
      if (value == true) controller.add(true);
    });
  });
  ref.onDispose(controller.close);
  return controller.stream;
});

/// ─────────────────────────────────────────────────────────────────────────────
/// NOTIFICATIONS (Kept from original logic)
/// ─────────────────────────────────────────────────────────────────────────────
final _local = FlutterLocalNotificationsPlugin();

@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // ... (Handler logic from original file)
}

class Notifier {
  static const _channelId = 'intellidesk_alerts_loud';
  static const _channelName = 'Alerts (Loud)';
  static const _channelDesc =
      'High-priority alerts with long vibration + sound';

  static bool _initialized = false;

  static Future<void> init() async {
    if (kIsWeb || !kUseFcm || _initialized) return;
    _initialized = true;

    try {
      await _local.initialize(
        const InitializationSettings(
          android: AndroidInitializationSettings('@mipmap/ic_launcher'),
          iOS: DarwinInitializationSettings(),
        ),
      );
      final androidChannel = AndroidNotificationChannel(
        _channelId,
        _channelName,
        description: _channelDesc,
        importance: Importance.max,
        playSound: true,
        enableVibration: true,
        vibrationPattern: kVibrate10s,
        sound: RawResourceAndroidNotificationSound(kNotificationSound),
      );
      await _local
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(androidChannel);
    } catch (e) {
      debugPrint('Notifier init error: $e');
    }
  }

  static Future<void> show({
    required String title,
    required String body,
  }) async {
    if (kIsWeb) return;
    try {
      final android = AndroidNotificationDetails(
        _channelId,
        _channelName,
        importance: Importance.max,
        priority: Priority.max,
        playSound: true,
        enableVibration: true,
        vibrationPattern: kVibrate10s,
        sound: RawResourceAndroidNotificationSound(kNotificationSound),
      );
      final details = NotificationDetails(
        android: android,
        iOS: const DarwinNotificationDetails(presentSound: true),
      );
      await _local.show(
        DateTime.now().millisecondsSinceEpoch ~/ 1000,
        title,
        body,
        details,
      );
    } catch (e) {
      debugPrint('Notification show error: $e');
    }
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// ENTRY
/// ─────────────────────────────────────────────────────────────────────────────
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Custom error widget
  ErrorWidget.builder = (FlutterErrorDetails details) {
    // Return a simple widget, not a full app.
    // This will be placed inside the existing MaterialApp's tree.
    return Container(
      color: kBackgroundLight, // Use your app's background color
      alignment: Alignment.center,
      padding: const EdgeInsets.all(24.0),
      child: Text(
        'App Render Error:\n${details.exceptionAsString()}',
        style: const TextStyle(
          color: Colors.redAccent,
          fontSize: 14,
          fontWeight: FontWeight.bold,
          fontFamily: 'Lexend', // Ensure it has a font
        ),
        textAlign: TextAlign.center,
      ),
    );
  };

  // **FIX 1 (Your Step 3): Run the app immediately with a wrapper**
  runApp(
    ProviderScope(
      child: const InitWrapper(),
    ),
  );
}

class InitWrapper extends StatelessWidget {
  const InitWrapper({super.key});

  /// This method contains all the async init logic from the original main()
  Future<bool> _initialize() async {
    try {
      return await Future.any<bool>([
        Future.delayed(
            const Duration(seconds: 15), () => false), // Timeout after 15s
        () async {
          if (kUseFirebase || kUseFcm) {
            await Firebase.initializeApp(
              options: DefaultFirebaseOptions.currentPlatform,
            );
          }
          if (kUseFcm) {
            await Notifier.init();
            FirebaseMessaging.onBackgroundMessage(
                _firebaseMessagingBackgroundHandler);
            final fbm = FirebaseMessaging.instance;

            // --- THIS IS THE CHANGE ---
            // The fbm.requestPermission() call is GONE from here.
            // MyApp will handle it after the UI is visible.
            // ---

            await fbm.setForegroundNotificationPresentationOptions(
              alert: true,
              badge: true,
              sound: true,
            );
            FirebaseMessaging.onMessage.listen((msg) async {
              final title = msg.notification?.title ?? 'Intellidesk';
              final body = msg.notification?.body ?? 'Update received';
              await Notifier.show(title: title, body: body);
            });
          }
          return true;
        }(),
      ]);
    } catch (error) {
      debugPrint('Error during initialization: $error');
      return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    // ... (The rest of the build method is unchanged)
    return FutureBuilder<bool>(
      future: _initialize(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          // Show a simple loading app while initializing
          return const MaterialApp(
            debugShowCheckedModeBanner: false,
            home: Scaffold(
              backgroundColor: kBackgroundLight, // Match theme
              body: Center(child: CircularProgressIndicator()),
            ),
          );
        }

        // Initialization is done, load the main app
        // We pass the success/fail state to LoadingApp
        return LoadingApp(initializationSuccess: snapshot.data ?? false);
      },
    );
  }
}

/// **FIX 2 (Your Step 2): This is now the SINGLE root MaterialApp**
class LoadingApp extends StatelessWidget {
  final bool initializationSuccess;
  const LoadingApp({super.key, required this.initializationSuccess});

  @override
  Widget build(BuildContext context) {
    // Decide which home widget to show
    final Widget homeWidget =
        initializationSuccess ? const MyApp() : const FallbackApp();

    // This is now the one and only MaterialApp
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Intellidesk', // Added title
      theme: ThemeData(
        brightness: Brightness.light,
        fontFamily: 'Lexend',
        scaffoldBackgroundColor: kBackgroundLight,
        primaryColor: kPrimaryBlue,
        colorScheme: ColorScheme.fromSeed(
          seedColor: kPrimaryBlue,
          brightness: Brightness.light,
          primary: kPrimaryBlue,
          surface: kBackgroundLight,
          onPrimary: Colors.white,
        ),
        useMaterial3: true,
        appBarTheme: const AppBarTheme(
          backgroundColor: kBackgroundLight,
          elevation: 0,
          scrolledUnderElevation: 0,
          surfaceTintColor: Colors.transparent,
          titleTextStyle: TextStyle(
            fontFamily: 'Lexend',
            color: Colors.black,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
          iconTheme: IconThemeData(color: Colors.black),
        ),
        cardTheme: CardThemeData(
          elevation: 0,
          color: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: const BorderRadius.all(Radius.circular(16)),
            side: BorderSide(color: Colors.grey.shade200, width: 1),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kBorderLight),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kBorderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kPrimaryBlue, width: 2),
          ),
          labelStyle: const TextStyle(color: kTextPrimaryLight),
          hintStyle: TextStyle(color: Colors.grey.shade400),
        ),
        filledButtonTheme: FilledButtonThemeData(
          style: FilledButton.styleFrom(
            backgroundColor: kPrimaryBlue,
            foregroundColor: Colors.white,
            minimumSize: const Size(double.infinity, 48),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8.0),
            ),
            textStyle: const TextStyle(
              fontFamily: 'Lexend',
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
        ),
        segmentedButtonTheme: SegmentedButtonThemeData(
          style: SegmentedButton.styleFrom(
            selectedBackgroundColor: Colors.white,
            selectedForegroundColor: kPrimaryBlue,
            backgroundColor: Colors.grey.shade200,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12.0),
            ),
          ),
        ),
        bottomNavigationBarTheme: const BottomNavigationBarThemeData(
          backgroundColor: Colors.white,
          selectedItemColor: kPrimaryBlue,
          unselectedItemColor: Colors.grey,
        ),
      ),
      home: homeWidget, // Set the home widget (MyApp or FallbackApp)
    );
  }
}

/// **FIX 3 (Your Step 2): This is no longer a MaterialApp**
class FallbackApp extends StatelessWidget {
  const FallbackApp({super.key});
  @override
  Widget build(BuildContext context) {
    // It's just a Scaffold. The theme comes from LoadingApp.
    return const Scaffold(
      body: Center(
        child: Text(
          'Failed to initialize Firebase.\nCheck console for details.',
          style: TextStyle(color: Colors.redAccent, fontSize: 20),
          textAlign: TextAlign.center,
        ),
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// DATABASE & FIRESTORE REFERENCES
/// ─────────────────────────────────────────────────────────────────────────────

FirebaseDatabase get _db => FirebaseDatabase.instanceFor(
      app: Firebase.app(),
      databaseURL: kDatabaseUrl,
    );

FirebaseFirestore get _fs => FirebaseFirestore.instance;

/// ─────────────────────────────────────────────────────────────────────────────
/// AUTH PROVIDER
/// ─────────────────────────────────────────────────────────────────────────────

String authErrorMessage(FirebaseAuthException e) {
  switch (e.code) {
    case 'invalid-email':
      return 'That email looks invalid.';
    case 'user-disabled':
      return 'This account has been disabled.';
    case 'user-not-found':
      return 'No account found for this email.';
    case 'wrong-password':
      return 'Incorrect password. Try again.';
    case 'too-many-requests':
      return 'Too many attempts. Please wait a moment and try again.';
    case 'network-request-failed':
      return 'Network error. Check your internet connection.';
    case 'weak-password':
      return 'Password is too weak.';
    case 'email-already-in-use':
      return 'An account already exists with this email.';
    default:
      return e.message ?? 'Login failed. Please try again.';
  }
}

class AuthController extends StateNotifier<AppUser?> {
  AuthController() : super(null) {
    FirebaseAuth.instance.authStateChanges().listen((u) {
      state = u == null ? null : AppUser(uid: u.uid, email: u.email ?? '');
    });
  }
  Future<void> signIn(String email, String password) async {
    await FirebaseAuth.instance.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
  }

  Future<void> signUp(String email, String password) async {
    await FirebaseAuth.instance.createUserWithEmailAndPassword(
      email: email,
      password: password,
    );
  }

  Future<void> signOut() async {
    await FirebaseAuth.instance.signOut();
  }
}

final authProvider = StateNotifierProvider<AuthController, AppUser?>(
  (ref) => AuthController(),
);

/// ─────────────────────────────────────────────────────────────────────────────
/// SENSOR PROVIDER
/// ─────────────────────────────────────────────────────────────────────────────

/// Sensor data stream (RTDB)
final sensorStreamProvider = StreamProvider<SensorData?>((ref) {
  if (!kUseFirebase) {
    return Stream.periodic(const Duration(seconds: 2), (i) {
      final s = DateTime.now().second;
      return SensorData(
        temperature: 22 + (s % 7).toDouble(),
        humidity: 40 + (s % 15).toDouble(),
        lightLux: 200 + (s % 600).toDouble(),
      );
    });
  }
  final refDb = _db.ref('/sensor_data');
  return refDb.onValue.map((e) {
    final val = e.snapshot.value;
    if (val is Map) return SensorData.fromMap(val);
    return null;
  });
});

/// ─────────────────────────────────────────────────────────────────────────────
/// ITEMS (BLE) PROVIDERS
/// ─────────────────────────────────────────────────────────────────────────────

/// Provider for the user's registered items (from Firestore)
class UserItemsNotifier extends StateNotifier<List<UserItem>> {
  final String userId;
  late final CollectionReference<Map<String, dynamic>> _itemsRef;
  StreamSubscription? _sub;

  UserItemsNotifier(this.userId) : super([]) {
    if (userId.isEmpty) return;
    _itemsRef = _fs.collection('users').doc(userId).collection('items');
    _listen();
  }

  void _listen() {
    _sub?.cancel();
    _sub = _itemsRef.snapshots().listen((snapshot) {
      state = snapshot.docs
          .map(
            (doc) => UserItem(
              macAddress: doc.id,
              name: doc.data()['name'] as String? ?? 'Unknown',
            ),
          )
          .toList();
    });
  }

  Future<void> add(String name, String mac) async {
    if (userId.isEmpty) return;
    final macUpper = mac.toUpperCase();
    await _itemsRef.doc(macUpper).set({
      'name': name,
      'macAddress': macUpper, // Store for convenience
    });
  }

  Future<void> remove(String mac) async {
    if (userId.isEmpty) return;
    await _itemsRef.doc(mac.toUpperCase()).delete();
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }
}

final userItemsProvider =
    StateNotifierProvider<UserItemsNotifier, List<UserItem>>((ref) {
  final user = ref.watch(authProvider);
  return UserItemsNotifier(user?.uid ?? '');
});

/// Provider for the LIVE status of all devices (from RTDB)
/// ESP32 writes here: /devices/AA:BB:CC:DD:EE:FF/connected = true
final devicesStatusProvider = StreamProvider<Map<String, bool>>((ref) {
  if (!kUseFirebase) {
    // Mock data for testing
    return Stream.periodic(const Duration(seconds: 2), (i) {
      return {
        'AA:BB:CC:DD:EE:FF': i % 2 == 0,
        '00:11:22:33:44:55': i % 3 == 0,
      };
    });
  }

  final refDb = _db.ref('/devices');

  return refDb.onValue.handleError((e) {
    debugPrint('Firebase stream error: $e');
  }).map((event) {
    final data = event.snapshot.value;

    // 🧱 Safety: handle null or non-map data
    if (data == null || data is! Map) return <String, bool>{};

    final statusMap = <String, bool>{};

    for (final entry in data.entries) {
      final mac = entry.key.toString().toUpperCase();
      final deviceData = entry.value;

      if (deviceData is Map) {
        statusMap[mac] = deviceData['connected'] == true;
      } else if (deviceData is bool) {
        statusMap[mac] = deviceData;
      } else {
        statusMap[mac] = false;
      }
    }

    return statusMap;
  });
});

/// Combined provider that merges the user's list with the live status
final trackableItemsProvider = Provider<List<TrackableItem>>((ref) {
  final userItems = ref.watch(userItemsProvider);
  final liveStatuses = ref.watch(devicesStatusProvider).asData?.value ?? {};

  return userItems.map((item) {
    final bool atHome = liveStatuses[item.macAddress.toUpperCase()] ?? false;
    return TrackableItem(id: item.macAddress, name: item.name, atHome: atHome);
  }).toList();
});

/// ─────────────────────────────────────────────────────────────────────────────
/// TASKS (TO-DO) PROVIDER
/// ─────────────────────────────────────────────────────────────────────────────

class TasksController extends StateNotifier<List<Task>> {
  final String userId;
  late final CollectionReference _tasksRef;
  StreamSubscription? _sub;

  TasksController(this.userId) : super(const []) {
    if (userId.isEmpty) return;
    _tasksRef = _fs.collection('users').doc(userId).collection('tasks');
    _listen();
  }

  void _listen() {
    _sub?.cancel();
    // Order by 'done' state (false first) then by creation time
    _sub = _tasksRef
        .orderBy('done')
        .orderBy('createdAt', descending: true)
        .snapshots()
        .listen((snapshot) {
      state = snapshot.docs.map((doc) {
        final data = doc.data() as Map<String, dynamic>;
        return Task(
          id: doc.id,
          title: data['title'],
          due: (data['due'] as Timestamp?)?.toDate(),
          done: data['done'] ?? false,
        );
      }).toList();
    });
  }

  void add(String title, {DateTime? due}) {
    if (title.trim().isEmpty || userId.isEmpty) return;
    _tasksRef.add({
      'title': title,
      'due': due,
      'done': false,
      'createdAt': FieldValue.serverTimestamp(),
    });
  }

  void toggle(String id) {
    if (userId.isEmpty) return;
    final task = state.firstWhere((t) => t.id == id);
    _tasksRef.doc(id).update({'done': !task.done});
  }

  void remove(String id) {
    if (userId.isEmpty) return;
    _tasksRef.doc(id).delete();
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }
}

final tasksProvider = StateNotifierProvider<TasksController, List<Task>>((ref) {
  final user = ref.watch(authProvider);
  return TasksController(user?.uid ?? '');
});

/// ─────────────────────────────────────────────────────────────────────────────
/// STUDY LOG PROVIDER
/// ─────────────────────────────────────────────────────────────────────────────
DateTime _dayKey(DateTime d) => DateTime(d.year, d.month, d.day);

class StudyLogNotifier extends StateNotifier<Map<DateTime, Duration>> {
  final String userId;
  late final CollectionReference _logsRef;

  StudyLogNotifier(this.userId) : super(<DateTime, Duration>{}) {
    if (userId.isEmpty) return;
    _logsRef = _fs.collection('users').doc(userId).collection('study_logs');
    _load();
  }

  Future<void> _load() async {
    final snapshot = await _logsRef.get();
    state = {
      for (final doc in snapshot.docs)
        DateTime.parse(doc.id): Duration(seconds: doc['duration'] as int),
    };
  }

  void addForToday(Duration d) {
    if (userId.isEmpty) return;
    final k = _dayKey(DateTime.now());
    final cur = state[k] ?? Duration.zero;
    final newTotal = cur + d;
    state = {...state, k: newTotal};
    _logsRef.doc(k.toIso8601String()).set({'duration': newTotal.inSeconds});
  }

  Duration get todayTotal {
    final k = _dayKey(DateTime.now());
    return state[k] ?? Duration.zero;
  }
}

final studyLogProvider =
    StateNotifierProvider<StudyLogNotifier, Map<DateTime, Duration>>((ref) {
  final user = ref.watch(authProvider);
  return StudyLogNotifier(user?.uid ?? '');
});

/// ─────────────────────────────────────────────────────────────────────────────
/// TIMER PROVIDER
/// ────────────────────────────────────────────────────────────────────────────

class TimerState {
  final Duration total, remaining;
  final bool running, isBreak;
  const TimerState({
    required this.total,
    required this.remaining,
    required this.running,
    required this.isBreak,
  });

  String get mmss {
    final m = remaining.inMinutes.remainder(60).toString().padLeft(2, '0');
    final s = remaining.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$m:$s';
  }
}

class TimerController extends StateNotifier<TimerState> {
  final Ref ref;
  Timer? _ticker;
  Duration _studiedThisSession = Duration.zero;

  TimerController(this.ref)
      : super(
          const TimerState(
            total: Duration.zero,
            remaining: Duration.zero,
            running: false,
            isBreak: false,
          ),
        );

  void _tick() {
    final next = state.remaining - const Duration(seconds: 1);

    if (!state.isBreak) {
      _studiedThisSession += const Duration(seconds: 1);
    }

    if (next <= Duration.zero) {
      _ticker?.cancel();
      _saveStudyTime();

      // Timer finished
      state = TimerState(
        total: state.total,
        remaining: Duration.zero,
        running: false,
        isBreak: state.isBreak,
      );

      // If it was a focus session, auto-start a break
      if (!state.isBreak) {
        int breakMinutes;
        if (state.total.inMinutes <= 25) {
          breakMinutes = 5;
        } else if (state.total.inMinutes <= 45) {
          breakMinutes = 10;
        } else {
          breakMinutes = 15;
        }
        startBreak(Duration(minutes: breakMinutes));
      }
    } else {
      // Timer continues
      state = TimerState(
        total: state.total,
        remaining: next,
        running: true,
        isBreak: state.isBreak,
      );
    }
  }

  void _saveStudyTime() {
    if (_studiedThisSession > Duration.zero) {
      ref.read(studyLogProvider.notifier).addForToday(_studiedThisSession);
      _studiedThisSession = Duration.zero;
    }
  }

  void startFocus(Duration d) {
    _ticker?.cancel();
    _saveStudyTime(); // Save any previous session
    state = TimerState(total: d, remaining: d, running: true, isBreak: false);
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
  }

  void startBreak(Duration d) {
    _ticker?.cancel();
    _saveStudyTime();
    state = TimerState(total: d, remaining: d, running: true, isBreak: true);
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
  }

  void pause() {
    if (!state.running) return;
    _ticker?.cancel();
    _saveStudyTime();
    state = TimerState(
      total: state.total,
      remaining: state.remaining,
      running: false,
      isBreak: state.isBreak,
    );
  }

  void resume() {
    if (state.running || state.remaining == Duration.zero) return;
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
    state = TimerState(
      total: state.total,
      remaining: state.remaining,
      running: true,
      isBreak: state.isBreak,
    );
  }

  void reset() {
    _ticker?.cancel();
    _saveStudyTime();
    state = const TimerState(
      total: Duration.zero,
      remaining: Duration.zero,
      running: false,
      isBreak: false,
    );
  }

  @override
  void dispose() {
    _ticker?.cancel();
    _saveStudyTime();
    super.dispose();
  }
}

final timerProvider = StateNotifierProvider<TimerController, TimerState>(
  (ref) => TimerController(ref),
);

/// ─────────────────────────────────────────────────────────────────────────────
/// APP ROOT (NEW LIGHT THEME)
/// ─────────────────────────────────────────────────────────────────────────────

class MyApp extends ConsumerWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(authProvider);

    // This is your excellent fix for web
    if (kIsWeb && kUseFcm) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        final fbm = FirebaseMessaging.instance;
        final settings = await fbm.requestPermission(
          alert: true,
          badge: true,
          sound: true,
        );
        debugPrint(
            'Post-frame permission status: ${settings.authorizationStatus}');
      });
    }

    // The theme is now in LoadingApp.
    // This widget just decides between Login and AppShell.
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      child: user == null
          ? const LoginScreen() // Start at Login screen
          : const _AppShell(),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// AUTH SCREENS (NEW UI)
/// ─────────────────────────────────────────────────────────────────────────────

class LoginScreen extends ConsumerWidget {
  const LoginScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    'Intellidesk',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: kPrimaryBlue,
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 48),
                  _AuthFormBody(
                    isLogin: true,
                    onSubmit: (email, password) async {
                      await ref
                          .read(authProvider.notifier)
                          .signIn(email, password);
                    },
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Don't have an account? "),
                      GestureDetector(
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const SignUpScreen(),
                            ),
                          );
                        },
                        child: const Text(
                          'Sign up',
                          style: TextStyle(
                            color: kPrimaryBlue,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class SignUpScreen extends ConsumerWidget {
  const SignUpScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        // Back button
        elevation: 0,
        backgroundColor: Colors.transparent,
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    'Intellidesk',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: kPrimaryBlue,
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 48),
                  _AuthFormBody(
                    isLogin: false,
                    onSubmit: (email, password) async {
                      await ref
                          .read(authProvider.notifier)
                          .signUp(email, password);
                    },
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Already have an account? "),
                      GestureDetector(
                        onTap: () {
                          Navigator.pop(context); // Go back to Login
                        },
                        child: const Text(
                          'Login',
                          style: TextStyle(
                            color: kPrimaryBlue,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AuthFormBody extends StatefulWidget {
  final bool isLogin;
  final Future<void> Function(String email, String password) onSubmit;

  const _AuthFormBody({required this.isLogin, required this.onSubmit});

  @override
  State<_AuthFormBody> createState() => _AuthFormBodyState();
}

class _AuthFormBodyState extends State<_AuthFormBody> {
  final _emailC = TextEditingController();
  final _passC = TextEditingController();
  final _confirmPassC = TextEditingController();

  bool _obscurePass = true;
  bool _obscureConfirm = true;
  bool _busy = false;
  String? _errorText;

  @override
  void dispose() {
    _emailC.dispose();
    _passC.dispose();
    _confirmPassC.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!mounted) return;
    setState(() {
      _busy = true;
      _errorText = null;
    });

    if (!widget.isLogin && _passC.text != _confirmPassC.text) {
      setState(() {
        _errorText = "Passwords do not match";
        _busy = false;
      });
      return;
    }

    try {
      await widget.onSubmit(_emailC.text.trim(), _passC.text);
      // Auth listener will handle navigation
    } on FirebaseAuthException catch (e) {
      if (!mounted) return;
      setState(() {
        _errorText = authErrorMessage(e);
        _busy = false;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _errorText = "An unknown error occurred.";
        _busy = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Email
        const Text("Email", style: TextStyle(fontWeight: FontWeight.w500)),
        const SizedBox(height: 8),
        TextField(
          controller: _emailC,
          keyboardType: TextInputType.emailAddress,
          decoration: const InputDecoration(
            hintText: 'Enter your email',
            contentPadding: EdgeInsets.all(15),
          ),
        ),
        const SizedBox(height: 16),
        // Password
        const Text("Password", style: TextStyle(fontWeight: FontWeight.w500)),
        const SizedBox(height: 8),
        TextField(
          controller: _passC,
          obscureText: _obscurePass,
          decoration: InputDecoration(
            hintText: 'Enter your password',
            contentPadding: const EdgeInsets.all(15),
            suffixIcon: IconButton(
              icon: Icon(
                _obscurePass ? Icons.visibility_off : Icons.visibility,
              ),
              onPressed: () => setState(() => _obscurePass = !_obscurePass),
            ),
          ),
        ),
        if (!widget.isLogin) ...[
          const SizedBox(height: 16),
          // Confirm Password
          const Text(
            "Confirm Password",
            style: TextStyle(fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 8),
          TextField(
            controller: _confirmPassC,
            obscureText: _obscureConfirm,
            decoration: InputDecoration(
              hintText: 'Confirm your password',
              contentPadding: const EdgeInsets.all(15),
              suffixIcon: IconButton(
                icon: Icon(
                  _obscureConfirm ? Icons.visibility_off : Icons.visibility,
                ),
                onPressed: () =>
                    setState(() => _obscureConfirm = !_obscureConfirm),
              ),
            ),
          ),
        ],
        const SizedBox(height: 24),
        if (_errorText != null)
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0),
            child: Text(
              _errorText!,
              style: const TextStyle(
                color: Colors.red,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        FilledButton(
          onPressed: _busy ? null : _submit,
          child: _busy
              ? const SizedBox(
                  height: 24,
                  width: 24,
                  child: CircularProgressIndicator(
                    color: Colors.white,
                    strokeWidth: 3,
                  ),
                )
              : Text(widget.isLogin ? 'Login' : 'Create Account'),
        ),
      ],
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// APP SHELL (4-TAB NAVIGATION)
/// ─────────────────────────────────────────────────────────────────────────────
class _AppShell extends StatefulWidget {
  const _AppShell();
  @override
  State<_AppShell> createState() => _AppShellState();
}

class _AppShellState extends State<_AppShell> {
  int _idx = 0;
  final _pages = const [_HomePage(), _FocusPage(), _ItemsPage(), _TasksPage()];

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(index: _idx, children: _pages),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _idx,
        onDestinationSelected: (v) => setState(() => _idx = v),
        destinations: const [
          NavigationDestination(
            icon: Icon(Icons.home_outlined),
            selectedIcon: Icon(Icons.home),
            label: 'Home',
          ),
          NavigationDestination(
            icon: Icon(Icons.timer_outlined),
            selectedIcon: Icon(Icons.timer),
            label: 'Focus',
          ),
          NavigationDestination(
            icon: Icon(Icons.link_outlined),
            selectedIcon: Icon(Icons.link),
            label: 'Items',
          ),
          NavigationDestination(
            icon: Icon(Icons.task_alt_outlined),
            selectedIcon: Icon(Icons.task_alt),
            label: 'Tasks',
          ),
        ],
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// TAB 1: HOME (DASHBOARD) SCREEN
/// ─────────────────────────────────────────────────────────────────────────────

class _HomePage extends ConsumerWidget {
  const _HomePage();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // 1. Watch all the data providers we need
    final studyLog = ref.watch(studyLogProvider);
    final sensorData = ref.watch(sensorStreamProvider);
    final items = ref.watch(trackableItemsProvider);
    final user = ref.watch(authProvider);

    // 2. Get specific values, with fallbacks
    final todayStudy = studyLog[_dayKey(DateTime.now())] ?? Duration.zero;
    final studyHours = todayStudy.inHours;
    final studyMinutes = todayStudy.inMinutes.remainder(60);

    final temp =
        sensorData.asData?.value?.temperature?.toStringAsFixed(1) ?? '--';
    final humidity =
        sensorData.asData?.value?.humidity?.toStringAsFixed(0) ?? '--';
    final light =
        sensorData.asData?.value?.lightLux?.toStringAsFixed(0) ?? '--';

    final itemsAtHome = items.where((i) => i.atHome).length;

    // 3. Listen for "left-home" alerts
    ref.listen(leftHomeAnyProvider, (prev, next) async {
      if (next.value == true) {
        final leftItems =
            items.where((i) => !i.atHome).map((e) => e.name).toList();
        final msg = leftItems.isEmpty
            ? 'You left home, but all items are with you!'
            : 'Did you forget? Items left at home: ${leftItems.join(', ')}';

        ScaffoldMessenger.of(
          context,
        ).showSnackBar(SnackBar(content: Text(msg)));
        if (kUseFcm && !kIsWeb) {
          await Notifier.show(title: 'Intellidesk Alert', body: msg);
        }
      }
    });

    return Scaffold(
      appBar: AppBar(
        title: const Text('Intellidesk'),
        actions: [
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: GestureDetector(
              onTap: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => const ProfileScreen()),
                );
              },
              child: CircleAvatar(
                radius: 20,
                backgroundColor: Colors.grey.shade200,
                // Using an icon as placeholder like in the design
                child: const Icon(Icons.person, color: Colors.grey),
              ),
            ),
          ),
        ],
      ),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          Text(
            'Hello, ${user?.displayName ?? 'User'}!',
            style: Theme.of(
              context,
            ).textTheme.headlineMedium?.copyWith(fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 24),

          // 4. Build the new dashboard grid
          GridView(
            gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
              crossAxisCount: 2,
              crossAxisSpacing: 16,
              mainAxisSpacing: 16,
              childAspectRatio: 1.0, // Make them square
            ),
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            children: [
              // Study Time Tile
              _DashboardTile(
                icon: Icons.school,
                title: 'Today\'s Study',
                value: '${studyHours}h ${studyMinutes}m',
                color: const Color(0xFF007AFF), // Blue from design
              ),

              // Paired Items Tile
              _DashboardTile(
                icon: Icons.link,
                title: 'Items at Home',
                value: '$itemsAtHome Items',
                color: const Color(0xFF34C759), // Green from design
              ),

              // Temperature Tile
              _DashboardTile(
                icon: Icons.thermostat,
                title: 'Room Temp',
                value: '$temp °C',
                color: const Color(0xFFFF9500), // Orange from design
              ),

              // Humidity Tile
              _DashboardTile(
                icon: Icons.water_drop,
                title: 'Humidity',
                value: '$humidity %',
                color: const Color(0xFF32ADE6), // Cyan from design
              ),

              // Light Tile
              _DashboardTile(
                icon: Icons.lightbulb,
                title: 'Light Level',
                value: '$light lx',
                color: const Color(0xFFFFCC00), // Yellow from design
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// Helper for the Home Page Dashboard
class _DashboardTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String value;
  final Color color;

  const _DashboardTile({
    required this.icon,
    required this.title,
    required this.value,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Card(
      elevation: 0,
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(20), // More rounded
        side: BorderSide(color: Colors.grey.shade200, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.spaceBetween,
          children: [
            Icon(icon, size: 32, color: color),
            Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  title,
                  style: Theme.of(context).textTheme.bodyMedium?.copyWith(
                        color: const Color(0xFF8A8A8F), // Gray from design
                      ),
                ),
                Text(
                  value,
                  style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: Colors.black,
                      ),
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// PROFILE SCREEN (NEW)
/// ─────────────────────────────────────────────────────────────────────────────

class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(authProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Profile & Settings')),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          Center(
            child: Column(
              children: [
                CircleAvatar(
                  radius: 50,
                  backgroundColor: Theme.of(
                    context,
                  ).colorScheme.primaryContainer,
                  child: Text(
                    user?.displayName.substring(0, 1).toUpperCase() ?? '?',
                    style: TextStyle(
                      fontSize: 40,
                      fontWeight: FontWeight.bold,
                      color: Theme.of(context).colorScheme.primary,
                    ),
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  user?.email ?? 'No email',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
              ],
            ),
          ),
          const SizedBox(height: 32),
          Card(
            child: Column(
              children: [
                ListTile(
                  leading: const Icon(Icons.notifications_outlined),
                  title: const Text('Notification Settings'),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {},
                ),
                ListTile(
                  leading: const Icon(Icons.link_outlined),
                  title: const Text('Manage Items'),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    // This could navigate to the Items tab
                    // Or be a separate management screen
                  },
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          Card(
            child: ListTile(
              leading: const Icon(Icons.logout, color: Colors.red),
              title: const Text(
                'Sign Out',
                style: TextStyle(color: Colors.red),
              ),
              onTap: () async {
                await ref.read(authProvider.notifier).signOut();
                if (context.mounted) {
                  // Pop back to the root (LoginScreen)
                  Navigator.of(context).popUntil((route) => route.isFirst);
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// TAB 2: FOCUS SCREEN (NEW TIMER UI)
/// ─────────────────────────────────────────────────────────────────────────────

class _FocusPage extends ConsumerStatefulWidget {
  const _FocusPage();
  @override
  ConsumerState<_FocusPage> createState() => _FocusPageState();
}

class _FocusPageState extends ConsumerState<_FocusPage> {
  // Store the selected focus time locally
  int _focusMinutes = 25;

  void _startTimer() {
    // Re-using the EnvCheckScreen from the original app logic
    Navigator.of(context)
        .push<bool>(
      MaterialPageRoute(
        builder: (_) => EnvCheckScreen(mode: 'Focus', minutes: _focusMinutes),
      ),
    )
        .then((skipped) {
      if (skipped == true && mounted) {
        ref
            .read(timerProvider.notifier)
            .startFocus(Duration(minutes: _focusMinutes));
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final timer = ref.watch(timerProvider);
    final timerNotifier = ref.read(timerProvider.notifier);

    final bool isRunning = timer.running;
    final bool isPaused = !timer.running && timer.remaining > Duration.zero;

    // Calculate progress for the animation
    double progress = 0.0;
    if (timer.total.inSeconds > 0) {
      progress = timer.remaining.inSeconds / timer.total.inSeconds;
    }

    final String timeDisplay =
        (timer.remaining > Duration.zero || timer.running)
            ? timer.mmss
            : '${_focusMinutes.toString().padLeft(2, '0')}:00';

    return Scaffold(
      appBar: AppBar(
        title: Text(timer.isBreak ? 'Break Time' : 'Stay Focused'),
        centerTitle: true,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),
            // 1. The Simple Animated Timer
            SizedBox(
              width: 250,
              height: 250,
              child: Stack(
                fit: StackFit.expand,
                children: [
                  // Use TweenAnimation for a smooth progress animation
                  TweenAnimationBuilder<double>(
                    tween: Tween(begin: 1.0, end: progress),
                    duration: const Duration(milliseconds: 200),
                    builder: (context, value, child) {
                      return CircularProgressIndicator(
                        value: value,
                        strokeWidth: 12,
                        backgroundColor: Colors.grey.shade200,
                        strokeCap: StrokeCap.round,
                        valueColor: const AlwaysStoppedAnimation(kPrimaryBlue),
                      );
                    },
                  ),
                  Center(
                    child: Text(
                      timeDisplay,
                      style: Theme.of(context).textTheme.displayLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: kTextPrimaryLight,
                        fontFeatures: [const FontFeature.tabularFigures()],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 30),

            // 2. Time selection (only show when timer is idle)
            if (!isRunning && !isPaused)
              SegmentedButton<int>(
                segments: const [
                  ButtonSegment(value: 25, label: Text('25 min')),
                  ButtonSegment(value: 45, label: Text('45 min')),
                  ButtonSegment(value: 60, label: Text('60 min')),
                ],
                selected: {_focusMinutes},
                onSelectionChanged: (newSelection) {
                  setState(() {
                    _focusMinutes = newSelection.first;
                  });
                },
              ),
            const Spacer(),

            // 3. Control Buttons
            Padding(
              padding: const EdgeInsets.only(bottom: 48.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  // Reset Button
                  SizedBox(
                    width: 64,
                    height: 64,
                    child: IconButton(
                      iconSize: 32,
                      icon: const Icon(Icons.refresh),
                      color: Colors.black54,
                      onPressed: (timer.remaining > Duration.zero || isRunning)
                          ? () => timerNotifier.reset()
                          : null,
                    ),
                  ),
                  const SizedBox(width: 20),

                  // Main Play/Pause/Start Button
                  SizedBox(
                    width: 80,
                    height: 80,
                    child: IconButton.filled(
                      iconSize: 48,
                      style: IconButton.styleFrom(
                        backgroundColor: kPrimaryBlue,
                      ),
                      onPressed: () {
                        if (isRunning) {
                          timerNotifier.pause();
                        } else if (isPaused) {
                          timerNotifier.resume();
                        } else {
                          _startTimer();
                        }
                      },
                      icon: Icon(isRunning ? Icons.pause : Icons.play_arrow),
                    ),
                  ),

                  // Spacer for balance
                  const SizedBox(width: 20 + 64),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// TAB 3: ITEMS SCREEN (NEW UI)
/// ─────────────────────────────────────────────────────────────────────────────
class _ItemsPage extends ConsumerWidget {
  const _ItemsPage();

  // This is the new dialog to add an item
  void _showAddItemDialog(BuildContext context, WidgetRef ref) {
    final nameController = TextEditingController();
    final macController = TextEditingController();

    showModalBottomSheet(
      context: context,
      isScrollControlled: true, // Important for keyboard
      backgroundColor: Colors.transparent, // For custom rounded corners
      builder: (ctx) => Container(
        padding: EdgeInsets.fromLTRB(
          20,
          20,
          20,
          MediaQuery.of(ctx).viewInsets.bottom + 20,
        ),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
          ),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Handle
            Center(
              child: Container(
                width: 48,
                height: 5,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(10),
                ),
              ),
            ),
            const SizedBox(height: 20),
            Text(
              'Add New Item',
              textAlign: TextAlign.center,
              style: Theme.of(
                context,
              ).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            const Text(
              "Item Name",
              style: TextStyle(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'e.g., My Backpack'),
            ),
            const SizedBox(height: 16),
            const Text(
              "Bluetooth MAC Address",
              style: TextStyle(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: macController,
              decoration: const InputDecoration(hintText: 'AA:BB:CC:DD:EE:FF'),
            ),
            const SizedBox(height: 24),
            FilledButton(
              onPressed: () {
                final name = nameController.text.trim();
                final mac = macController.text.trim().toUpperCase();

                if (name.isNotEmpty && mac.isNotEmpty) {
                  ref.read(userItemsProvider.notifier).add(name, mac);
                  Navigator.pop(ctx);
                  ScaffoldMessenger.of(
                    context,
                  ).showSnackBar(SnackBar(content: Text('$name added!')));
                }
              },
              child: const Text('Save Item'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final items = ref.watch(trackableItemsProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('My Items')),
      body: items.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.bluetooth_searching,
                    size: 80,
                    color: Colors.grey.shade400,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No Items Found',
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Tap the '+' button to add your first item.",
                    style: Theme.of(context).textTheme.bodyLarge,
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: items.length,
              itemBuilder: (context, index) {
                final item = items[index];
                return _ItemTile(item: item);
              },
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddItemDialog(context, ref),
        child: const Icon(Icons.add),
      ),
    );
  }
}

/// Helper for the Items Page
class _ItemTile extends ConsumerWidget {
  final TrackableItem item;
  const _ItemTile({required this.item});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bool atHome = item.atHome;
    // From design: status-green-text, status-gray-text
    final Color statusColor =
        atHome ? const Color(0xFF34C759) : const Color(0xFF8E8E93);
    // From design: status-green-bg, status-gray-bg
    final Color statusBgColor =
        atHome ? const Color(0x1A34C759) : const Color(0x1A8E8E93);
    final IconData statusIcon =
        atHome ? Icons.check_circle : Icons.remove_circle_outline;

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16), // xl
        side: BorderSide(color: Colors.grey.shade200, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          children: [
            Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: statusBgColor,
                shape: BoxShape.circle,
              ),
              child: Icon(statusIcon, color: statusColor, size: 28),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    item.name,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                    ),
                  ),
                  Text(
                    item.id, // The MAC address
                    style: const TextStyle(color: Colors.grey, fontSize: 14),
                  ),
                ],
              ),
            ),
            Text(
              atHome ? 'At Home' : 'Away',
              style: TextStyle(color: statusColor, fontWeight: FontWeight.w500),
            ),
          ],
        ),
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// TAB 4: TASKS (TO-DO) SCREEN
/// ─────────────────────────────────────────────────────────────────────────────
class _TasksPage extends ConsumerStatefulWidget {
  const _TasksPage({super.key});

  @override
  ConsumerState<_TasksPage> createState() => _TasksPageState();
}

class _TasksPageState extends ConsumerState<_TasksPage> {
  final _taskController = TextEditingController();

  @override
  void dispose() {
    _taskController.dispose();
    super.dispose();
  }

  void _addTask() {
    final title = _taskController.text.trim();
    if (title.isEmpty) return;

    ref.read(tasksProvider.notifier).add(title);

    _taskController.clear();
    FocusScope.of(context).unfocus(); // Hide keyboard
  }

  @override
  Widget build(BuildContext context) {
    final tasks = ref.watch(tasksProvider);

    // Separate tasks for better UI
    final pendingTasks = tasks.where((t) => !t.done).toList();
    final completedTasks = tasks.where((t) => t.done).toList();

    return Scaffold(
      appBar: AppBar(title: const Text('My Tasks')),
      body: Column(
        children: [
          Expanded(
            child: ListView(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              children: [
                // Pending Tasks Section
                Text(
                  'To-Do',
                  style: Theme.of(
                    context,
                  ).textTheme.titleLarge?.copyWith(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 8),
                if (pendingTasks.isEmpty)
                  const Center(
                    child: Padding(
                      padding: EdgeInsets.all(32.0),
                      child: Text(
                        'All caught up! 🎉',
                        style: TextStyle(color: Colors.grey, fontSize: 16),
                      ),
                    ),
                  ),
                ...pendingTasks.map((task) => _TaskTile(task: task)),

                // Completed Tasks Section
                if (completedTasks.isNotEmpty) ...[
                  const SizedBox(height: 24),
                  Text(
                    'Completed',
                    style: Theme.of(context).textTheme.titleLarge?.copyWith(
                          fontWeight: FontWeight.bold,
                        ),
                  ),
                  const SizedBox(height: 8),
                  ...completedTasks.map((task) => _TaskTile(task: task)),
                ],
              ],
            ),
          ),
          // 4. "Add Task" text field at the bottom
          _buildAddTaskBar(),
        ],
      ),
    );
  }

  // Helper for the bottom text bar
  Widget _buildAddTaskBar() {
    return Container(
      padding: EdgeInsets.fromLTRB(
        16,
        8,
        8,
        MediaQuery.of(context).viewInsets.bottom + 16,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        border: Border(top: BorderSide(color: Colors.grey.shade200, width: 1)),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _taskController,
              decoration: const InputDecoration(
                hintText: 'Add a new task...',
                border: InputBorder.none,
                enabledBorder: InputBorder.none,
                focusedBorder: InputBorder.none,
              ),
              onSubmitted: (_) => _addTask(),
            ),
          ),
          IconButton(
            icon: const Icon(Icons.add),
            style: IconButton.styleFrom(
              backgroundColor: kPrimaryBlue,
              foregroundColor: Colors.white,
            ),
            onPressed: _addTask,
          ),
        ],
      ),
    );
  }
}

/// Helper for the Tasks Page
class _TaskTile extends ConsumerWidget {
  final Task task;

  const _TaskTile({required this.task});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Card(
      margin: const EdgeInsets.symmetric(vertical: 4),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16), // xl
        side: BorderSide(color: Colors.grey.shade200, width: 1),
      ),
      child: CheckboxListTile(
        value: task.done,
        onChanged: (val) {
          ref.read(tasksProvider.notifier).toggle(task.id);
        },
        title: Text(
          task.title,
          style: TextStyle(
            decoration:
                task.done ? TextDecoration.lineThrough : TextDecoration.none,
            color: task.done ? Colors.grey : kTextPrimaryLight,
          ),
        ),
        controlAffinity: ListTileControlAffinity.leading,
        activeColor: kPrimaryBlue,
        checkboxShape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(6),
        ),
      ),
    );
  }
}

/// ─────────────────────────────────────────────────────────────────────────────
/// ENV CHECK (Kept from original)
/// ─────────────────────────────────────────────────────────────────────────────

class EnvCheckScreen extends ConsumerStatefulWidget {
  final String mode; // "Focus" or "Break"
  final int minutes;
  const EnvCheckScreen({super.key, required this.mode, required this.minutes});

  @override
  ConsumerState<EnvCheckScreen> createState() => _EnvCheckScreenState();
}

class _EnvCheckScreenState extends ConsumerState<EnvCheckScreen> {
  // Comfort ranges
  static const double _tMin = 23.0, _tMax = 27.0; // °C
  static const double _hMin = 40.0, _hMax = 60.0; // %
  static const double _luxMin = 300.0, _luxMax = 750.0; // lux

  String _tipForTemp(double? t) {
    if (t == null) return 'Waiting for temperature…';
    if (t < _tMin) return 'Feels cold. Close a window?';
    if (t > _tMax) return 'Feels warm. Open a window?';
    return 'Great temperature for studying.';
  }

  String _tipForHum(double? h) {
    if (h == null) return 'Waiting for humidity…';
    if (h < _hMin) return 'Air is dry. A humidifier can help.';
    if (h > _hMax) return 'Air is humid. Ventilation can help.';
    return 'Comfortable humidity.';
  }

  String _tipForLight(double? lux) {
    if (lux == null) return 'Waiting for light sensor…';
    if (lux < _luxMin) return 'Too dim. Turn on a light.';
    if (lux > _luxMax) return 'Too bright. Reduce glare.';
    return 'Ideal lighting for studying.';
  }

  @override
  Widget build(BuildContext context) {
    final sensor = ref.watch(sensorStreamProvider);
    final temp = sensor.asData?.value?.temperature;
    final hum = sensor.asData?.value?.humidity;
    final light = sensor.asData?.value?.lightLux;

    final tempOk = temp != null && temp >= _tMin && temp <= _tMax;
    final humOk = hum != null && hum >= _hMin && hum <= _hMax;
    final lightOk = light != null && light >= _luxMin && light <= _luxMax;

    return Scaffold(
      appBar: AppBar(title: Text('${widget.mode} Check'), centerTitle: true),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              Text(
                'Ready for your ${widget.minutes} minute session?',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              const Text(
                'Here\'s a check of your study environment:',
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),

              // Status rows
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      _CheckRow(
                        title: temp == null
                            ? 'Temperature'
                            : 'Temperature ${temp.toStringAsFixed(1)}°C',
                        ok: tempOk,
                        waiting: temp == null,
                        tip: _tipForTemp(temp),
                      ),
                      const Divider(height: 24),
                      _CheckRow(
                        title: hum == null
                            ? 'Humidity'
                            : 'Humidity ${hum.toStringAsFixed(0)}%',
                        ok: humOk,
                        waiting: hum == null,
                        tip: _tipForHum(hum),
                      ),
                      const Divider(height: 24),
                      _CheckRow(
                        title: light == null
                            ? 'Light Intensity'
                            : 'Light ${light.toStringAsFixed(0)} lux',
                        ok: lightOk,
                        waiting: light == null,
                        tip: _tipForLight(light),
                      ),
                    ],
                  ),
                ),
              ),

              const Spacer(),

              // CTA buttons
              FilledButton(
                onPressed: () => Navigator.pop(context, true), // Start
                child: Text('Start ${widget.mode} Session'),
              ),
              const SizedBox(height: 12),
              TextButton(
                onPressed: () => Navigator.pop(context, false), // Cancel
                child: const Text('Cancel'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Helper for EnvCheckScreen
class _CheckRow extends StatelessWidget {
  final String title;
  final bool ok;
  final bool waiting;
  final String tip;
  const _CheckRow({
    required this.title,
    required this.ok,
    required this.waiting,
    required this.tip,
  });

  @override
  Widget build(BuildContext context) {
    final Color color;
    final IconData icon;

    if (waiting) {
      color = Colors.grey;
      icon = Icons.more_horiz;
    } else if (ok) {
      color = Colors.green;
      icon = Icons.check_circle;
    } else {
      color = Colors.orange;
      icon = Icons.error_outline;
    }

    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: color, size: 28),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: Theme.of(
                  context,
                ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 4),
              Text(tip, style: Theme.of(context).textTheme.bodyMedium),
            ],
          ),
        ),
      ],
    );
  }
}
