// Dart Core
import 'dart:async';
import 'dart:io' show Platform;
// Flutter Core
import 'package:flutter/foundation.dart';
import 'package:flutter/material.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
// Device & Network
import 'package:connectivity_plus/connectivity_plus.dart';
import 'package:network_info_plus/network_info_plus.dart';
import 'package:permission_handler/permission_handler.dart';
// âœ… NEW: Imports for Battery Optimization
import 'package:device_info_plus/device_info_plus.dart';
import 'package:android_intent_plus/android_intent.dart';
// Firebase
import 'package:firebase_core/firebase_core.dart';
import 'package:firebase_database/firebase_database.dart';
import 'package:firebase_messaging/firebase_messaging.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:intl/intl.dart';
import 'firebase_options.dart'; // generated by `flutterfire configure`
// Local notifications
import 'package:flutter_local_notifications/flutter_local_notifications.dart';

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// CONFIG
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const bool kUseFirebase = true;
const bool kUseFcm = true;

final GlobalKey<NavigatorState> navigatorKey = GlobalKey<NavigatorState>();

/// Your RTDB URL (same as ESP32 firmware)
const String kDatabaseUrl =
    'https://intellideskisannoying-default-rtdb.asia-southeast1.firebasedatabase.app';
// 10s vibration (milliseconds): wait 0ms, vibrate 10,000ms
final Int64List kVibrate10s = Int64List.fromList(<int>[0, 10000]);
const String kNotificationSound = 'alert';
// --- CUSTOM THEME COLORS (from your new design) ---
const Color kPrimaryBlue = Color(0xFF4A90E2);
const Color kBackgroundLight = Color(0xFFF7F9FC);
const Color kTextPrimaryLight = Color(0xFF1E293B);
const Color kBorderLight = Color(0xFFCBD5E1);

// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// WIFI POLL CONFIG
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const Duration kWifiPollInterval = Duration(minutes: 1);

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// MODELS
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class AppUser {
  final String uid;
  final String email;
  final String displayName; // <-- THIS IS THE FIX

  AppUser({
    required this.uid,
    required this.email,
    required this.displayName,
  });
}

class Task {
  final String id;
  final String title;
  final DateTime? due;
  final bool done;
  final DateTime? createdAt; // âœ… FIXED: Added for sorting

  const Task({
    required this.id,
    required this.title,
    this.due,
    this.done = false,
    this.createdAt, // âœ… FIXED: Added to constructor
  });

  /// âœ… NEW: Creates a Task from Firestore data
  factory Task.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>;
    return Task(
      id: doc.id,
      title: data['title'] ?? 'Untitled Task',
      done: data['done'] == true,
      due: (data['due'] as Timestamp?)?.toDate(),
      createdAt: (data['createdAt'] as Timestamp?)
          ?.toDate(), // âœ… FIXED: Parse createdAt
    );
  }

  Task copyWith({String? title, DateTime? due, bool? done}) => Task(
        id: id,
        title: title ?? this.title,
        due: due ?? this.due,
        done: done ?? this.done,
        createdAt: createdAt,
      );

  /// Converts this Task object into a Map for Firestore.
  Map<String, dynamic> toFirestore() {
    return {
      'title': title,
      'due': due, // This is DateTime?, so it can be null
      'done': done,
      // If createdAt is null (e.g., new task), use serverTimestamp.
      // Otherwise, convert the existing DateTime to a Timestamp.
      'createdAt': createdAt == null
          ? FieldValue.serverTimestamp()
          : Timestamp.fromDate(createdAt!),
    };
  }
}

/// Model for an item the user has registered
class UserItem {
  final String macAddress;
  final String name;
  final bool atHome;

  const UserItem({
    required this.macAddress,
    required this.name,
    required this.atHome,
  });

  factory UserItem.fromRTDB(String id, Map<String, dynamic> map) {
    return UserItem(
      macAddress: (map['bleAddress'] ?? id).toString().toUpperCase(),
      name: (map['name'] ?? 'Unknown').toString(),
      atHome: map['atHome'] == true,
    );
  }

  Map<String, dynamic> toMap() => {
        'bleAddress': macAddress,
        'name': name,
        'atHome': atHome,
      };
}

class SensorData {
  final double? temperature;
  final double? humidity;
  final double? lightLux;

  const SensorData({
    this.temperature,
    this.humidity,
    this.lightLux,
  });

  factory SensorData.fromRTDB(Map<dynamic, dynamic>? data) {
    if (data == null) return const SensorData();
    return SensorData(
      temperature: (data['temperature'] as num?)?.toDouble(),
      humidity: (data['humidity'] as num?)?.toDouble(),
      lightLux: (data['light_lux'] as num?)?.toDouble(),
    );
  }

  Map<String, dynamic> toMap() => {
        'temperature': temperature,
        'humidity': humidity,
        'light_lux': lightLux,
      };
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// WIFI (phone) + left-home detection (Kept from original logic)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class HomeWifi {
  final String ssid;
  final String bssid;
  const HomeWifi({required this.ssid, required this.bssid});
}

bool _sameBssid(String? a, String? b) =>
    a != null && b != null && a.toUpperCase() == b.toUpperCase();
String? _cleanSsid(String? raw) {
  if (raw == null) return null;
  var s = raw.trim();
  if (s.isEmpty) return null;
  if (s.toLowerCase() == '<unknown ssid>') return null;
  if (s.length >= 2 && s.startsWith('"') && s.endsWith('"')) {
    s = s.substring(1, s.length - 1);
  }
  return s.isEmpty ? null : s;
}

/// Provider with Android 9 Permission Fix
/// Provider with Android 9 Permission Fix
final phoneWifiProvider = StreamProvider<HomeWifi?>((ref) async* {
  if (kIsWeb || !Platform.isAndroid) {
    yield null;
    return;
  }

  // âœ… 1. Define the permission request function (FIX: Renamed to remove underscore)
  Future<void> ensureWifiPermissions() async {
    if (!Platform.isAndroid) return;

    // Request location permission (needed for SSID/BSSID on Android 9)
    if (await Permission.locationWhenInUse.isDenied) {
      await Permission.locationWhenInUse.request();
    }

    // Optional: ask for notification permission
    if (await Permission.notification.isDenied) {
      await Permission.notification.request();
    }
  }

  // âœ… 2. Call the permission function (FIX: Renamed to remove underscore)
  await ensureWifiPermissions();

  final connectivity = Connectivity();
  final info = NetworkInfo();

  Future<HomeWifi?> readWifi() async {
    try {
      final results = await connectivity.checkConnectivity();
      if (!results.contains(ConnectivityResult.wifi)) return null;
      final ssid = _cleanSsid(await info.getWifiName());
      final bssid = await info.getWifiBSSID();
      if (ssid == null || bssid == null) return null;
      return HomeWifi(ssid: ssid, bssid: bssid);
    } catch (_) {
      return null;
    }
  }

  // Emit first reading
  yield await readWifi();

  // Merge periodic + connectivity events
  final controller = StreamController<HomeWifi?>();
  final sub = connectivity.onConnectivityChanged.listen((_) async {
    controller.add(await readWifi());
  });
  final timer = Timer.periodic(kWifiPollInterval, (_) async {
    controller.add(await readWifi());
  });

  ref.onDispose(() {
    sub.cancel();
    timer.cancel();
    controller.close();
  });

  // Distinct consecutive Wi-Fi states
  yield* controller.stream.distinct((a, b) {
    if (a == null && b == null) return true;
    if (a == null || b == null) return false;
    return a.ssid == b.ssid && a.bssid.toUpperCase() == b.bssid.toUpperCase();
  });
});

class EspWifi {
  final String ssid;
  final String bssid;
  const EspWifi({required this.ssid, required this.bssid});
  factory EspWifi.fromMap(Map m) => EspWifi(
        ssid: _cleanSsid(m['ssid'] as String?) ?? '',
        bssid: (m['bssid'] as String? ?? '').toUpperCase(),
      );
}

final espWifiProvider = StreamProvider<EspWifi?>((ref) {
  if (!kUseFirebase) return const Stream.empty();
  final refDb = _db.ref('/esp_wifi');
  return refDb.onValue.map((e) {
    final v = e.snapshot.value;
    if (v is Map) {
      try {
        final x = EspWifi.fromMap(v);
        if (x.bssid.isNotEmpty) return x;
      } catch (e) {
        debugPrint('ESP WiFi parse error: $e');
      }
    }
    return null;
  });
});
final atHomeNowProvider = Provider<bool?>((ref) {
  final phone = ref.watch(phoneWifiProvider).asData?.value;
  final esp = ref.watch(espWifiProvider).asData?.value;
  if (phone == null || esp == null) return null;
  return _sameBssid(phone.bssid, esp.bssid);
});
final leftHomeFromEspWifiProvider = StreamProvider<bool>((ref) {
  final c = StreamController<bool>.broadcast();
  bool? prev;
  ref.listen<bool?>(atHomeNowProvider, (_, cur) {
    if (prev == true && cur == false) c.add(true);
    prev = cur;
  });
  ref.onDispose(c.close);
  return c.stream;
});
final leftHomeAnyProvider = StreamProvider<bool>((ref) {
  final controller = StreamController<bool>.broadcast();
  ref.listen<AsyncValue<bool>>(leftHomeFromEspWifiProvider, (_, next) {
    next.whenData((value) {
      if (value == true) controller.add(true);
    });
  });
  ref.onDispose(controller.close);
  return controller.stream;
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// NOTIFICATIONS (Kept from original logic)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final _local = FlutterLocalNotificationsPlugin();
@pragma('vm:entry-point')
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // ... (Handler logic from original file)
}

class Notifier {
  static const _channelId = 'intellidesk_alerts_loud';
  static const _channelName = 'Alerts (Loud)';
  static const _channelDesc =
      'High-priority alerts with long vibration + sound';
  static bool _initialized = false;
  static Future<void> init() async {
    if (kIsWeb || !kUseFcm || _initialized) return;
    _initialized = true;
    try {
      await _local.initialize(
        const InitializationSettings(
          android: AndroidInitializationSettings('@mipmap/ic_launcher'),
          iOS: DarwinInitializationSettings(),
        ),
      );
      final androidChannel = AndroidNotificationChannel(
        _channelId,
        _channelName,
        description: _channelDesc,
        importance: Importance.max,
        playSound: true,
        enableVibration: true,
        vibrationPattern: kVibrate10s,
        sound: RawResourceAndroidNotificationSound(kNotificationSound),
      );
      await _local
          .resolvePlatformSpecificImplementation<
              AndroidFlutterLocalNotificationsPlugin>()
          ?.createNotificationChannel(androidChannel);
    } catch (e) {
      debugPrint('Notifier init error: $e');
    }
  }

  static Future<void> show({
    required String title,
    required String body,
  }) async {
    if (kIsWeb) return;
    try {
      final android = AndroidNotificationDetails(
        _channelId,
        _channelName,
        importance: Importance.max,
        priority: Priority.max,
        playSound: true,
        enableVibration: true,
        vibrationPattern: kVibrate10s,
        sound: RawResourceAndroidNotificationSound(kNotificationSound),
      );
      final details = NotificationDetails(
        android: android,
        iOS: const DarwinNotificationDetails(presentSound: true),
      );
      await _local.show(
        DateTime.now().millisecondsSinceEpoch ~/ 1000,
        title,
        body,
        details,
      );
    } catch (e) {
      debugPrint('Notification show error: $e');
    }
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// ENTRY
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
Future<void> main() async {
  WidgetsFlutterBinding.ensureInitialized();
  // Custom error widget
  ErrorWidget.builder = (FlutterErrorDetails details) {
    // Return a simple widget, not a full app.
    // This will be placed inside the existing MaterialApp's tree.
    return Container(
      color: kBackgroundLight, // Use your app's background color
      alignment: Alignment.center,
      padding: const EdgeInsets.all(24.0),
      child: Text(
        'App Render Error:\n${details.exceptionAsString()}',
        style: const TextStyle(
          color: Colors.redAccent,
          fontSize: 14,
          fontWeight: FontWeight.bold,
          fontFamily: 'Lexend', // Ensure it has a font
        ),
        textAlign: TextAlign.center,
      ),
    );
  };
  // **FIX 1 (Your Step 3): Run the app immediately with a wrapper**
  runApp(
    ProviderScope(
      child: const InitWrapper(),
    ),
  );
}

/// **FIX 1 (Your Step 3): New widget to handle async initialization**
class InitWrapper extends StatelessWidget {
  const InitWrapper({super.key});

  /// This method contains all the async init logic from the original main()
  Future<bool> _initialize() async {
    try {
      return await Future.any<bool>([
        Future.delayed(const Duration(seconds: 15), () => false), // Timeout
        () async {
          if (kUseFirebase || kUseFcm) {
            await Firebase.initializeApp(
              options: DefaultFirebaseOptions.currentPlatform,
            );
          }
          if (kUseFcm) {
            await Notifier.init();
            FirebaseMessaging.onBackgroundMessage(
                _firebaseMessagingBackgroundHandler);

            final fbm = FirebaseMessaging.instance;

            await fbm.setForegroundNotificationPresentationOptions(
              alert: true,
              badge: true,
              sound: true,
            );
            FirebaseMessaging.onMessage.listen((msg) async {
              final title = msg.notification?.title ?? 'Intellidesk';
              final body = msg.notification?.body ?? 'Update received';
              await Notifier.show(title: title, body: body);
            });
          }
          return true;
        }(),
      ]);
    } catch (error) {
      debugPrint('Error during initialization: $error');
      return false;
    }
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<bool>(
      future: _initialize(),
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          // Show a simple loading app while initializing
          return const MaterialApp(
            debugShowCheckedModeBanner: false,
            home: Scaffold(
              backgroundColor: kBackgroundLight, // Match theme
              body: Center(child: CircularProgressIndicator()),
            ),
          );
        }
        // Initialization is done, load the main app
        // We pass the success/fail state to LoadingApp
        return LoadingApp(initializationSuccess: snapshot.data ?? false);
      },
    );
  }
}

/// **FIX 2 (Your Step 2): This is now the SINGLE root MaterialApp**
class LoadingApp extends StatelessWidget {
  final bool initializationSuccess;
  const LoadingApp({super.key, required this.initializationSuccess});
  @override
  Widget build(BuildContext context) {
    // Decide which home widget to show
    final Widget homeWidget =
        initializationSuccess ? const MyApp() : const FallbackApp();
    // This is now the one and only MaterialApp
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      title: 'Intellidesk', // Added title
      navigatorKey: navigatorKey,
      theme: ThemeData(
        brightness: Brightness.light,
        fontFamily: 'Lexend',
        scaffoldBackgroundColor: kBackgroundLight,
        primaryColor: kPrimaryBlue,
        colorScheme: ColorScheme.fromSeed(
          seedColor: kPrimaryBlue,
          brightness: Brightness.light,
          primary: kPrimaryBlue,
          surface: kBackgroundLight,
          onPrimary: Colors.white,
        ),
        useMaterial3: true,
        appBarTheme: const AppBarTheme(
          backgroundColor: kBackgroundLight,
          elevation: 0,
          scrolledUnderElevation: 0,
          surfaceTintColor: Colors.transparent,
          titleTextStyle: TextStyle(
            fontFamily: 'Lexend',
            color: Colors.black,
            fontSize: 20,
            fontWeight: FontWeight.bold,
          ),
          iconTheme: IconThemeData(color: Colors.black),
        ),
        cardTheme: CardThemeData(
          elevation: 0,
          color: Colors.white,
          shape: RoundedRectangleBorder(
            borderRadius: const BorderRadius.all(Radius.circular(16)),
            side: BorderSide(color: Colors.grey.shade200, width: 1),
          ),
        ),
        inputDecorationTheme: InputDecorationTheme(
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kBorderLight),
          ),
          enabledBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kBorderLight),
          ),
          focusedBorder: OutlineInputBorder(
            borderRadius: BorderRadius.circular(8.0),
            borderSide: const BorderSide(color: kPrimaryBlue, width: 2),
          ),
          labelStyle: const TextStyle(color: kTextPrimaryLight),
          hintStyle: TextStyle(color: Colors.grey.shade400),
        ),
        filledButtonTheme: FilledButtonThemeData(
          style: FilledButton.styleFrom(
            backgroundColor: kPrimaryBlue,
            foregroundColor: Colors.white,
            minimumSize: const Size(double.infinity, 48),
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(8.0),
            ),
            textStyle: const TextStyle(
              fontFamily: 'Lexend',
              fontWeight: FontWeight.bold,
              fontSize: 16,
            ),
          ),
        ),
        segmentedButtonTheme: SegmentedButtonThemeData(
          style: SegmentedButton.styleFrom(
            selectedBackgroundColor: Colors.white,
            selectedForegroundColor: kPrimaryBlue,
            backgroundColor: Colors.grey.shade200,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(12.0),
            ),
          ),
        ),
        bottomNavigationBarTheme: const BottomNavigationBarThemeData(
          backgroundColor: Colors.white,
          selectedItemColor: kPrimaryBlue,
          unselectedItemColor: Colors.grey,
        ),
      ),
      home: homeWidget, // Set the home widget (MyApp or FallbackApp)
    );
  }
}

class FallbackApp extends StatelessWidget {
  const FallbackApp({super.key});
  @override
  Widget build(BuildContext context) {
    // It's just a Scaffold. The theme comes from LoadingApp.
    return const Scaffold(
      body: Center(
        child: Text(
          'Failed to initialize Firebase.\nCheck console for details.',
          style: TextStyle(color: Colors.redAccent, fontSize: 20),
          textAlign: TextAlign.center,
        ),
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// DATABASE & FIRESTORE REFERENCES
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
FirebaseDatabase get _db => FirebaseDatabase.instanceFor(
      app: Firebase.app(),
      databaseURL: kDatabaseUrl,
    );

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// AUTH PROVIDER
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
String authErrorMessage(FirebaseAuthException e) {
  switch (e.code) {
    case 'invalid-email':
      return 'That email looks invalid.';
    case 'user-disabled':
      return 'This account has been disabled.';
    case 'user-not-found':
      return 'No account found for this email.';
    case 'wrong-password':
      return 'Incorrect password. Try again.';
    case 'too-many-requests':
      return 'Too many attempts. Please wait a moment and try again.';
    case 'network-request-failed':
      return 'Network error. Check your internet connection.';
    case 'weak-password':
      return 'Password is too weak.';
    case 'email-already-in-use':
      return 'An account already exists with this email.';
    default:
      return e.message ?? 'Login failed. Please try again.';
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// AUTH PROVIDER
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class AuthController extends StateNotifier<AppUser?> {
  AuthController() : super(null) {
    FirebaseAuth.instance.authStateChanges().listen((u) {
      if (u == null) {
        state = null;
      } else {
        state = AppUser(
          uid: u.uid,
          email: u.email ?? '',
          displayName: u.displayName ?? u.email?.split('@')[0] ?? 'User',
        );
      }
    });
  }

  Future<void> signIn(String email, String password) async {
    await FirebaseAuth.instance.signInWithEmailAndPassword(
      email: email,
      password: password,
    );
  }

  Future<void> signUp(String email, String password) async {
    UserCredential userCredential =
        await FirebaseAuth.instance.createUserWithEmailAndPassword(
      email: email,
      password: password,
    );

    if (userCredential.user != null) {
      try {
        String newDisplayName = email.split('@')[0]; // Default name from email
        await userCredential.user!.updateDisplayName(newDisplayName);

        // Ensure the AuthStateChanges stream picks up the updated user immediately
        await userCredential.user!.reload();
      } catch (e) {
        // Log error but don't prevent signup from completing
        debugPrint('Error setting display name for new user: $e');
      }
    }
  }

  Future<void> signOut() async {
    await FirebaseAuth.instance.signOut();
  }
}

final authProvider = StateNotifierProvider<AuthController, AppUser?>(
  (ref) => AuthController(),
);

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// SENSOR PROVIDER Sensor data stream (RTDB)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final sensorStreamProvider = StreamProvider<SensorData?>((ref) {
  if (!kUseFirebase) {
    // âœ… Mock data for local testing
    return Stream.periodic(const Duration(seconds: 2), (i) {
      final s = DateTime.now().second;
      return SensorData(
        temperature: 22 + (s % 7).toDouble(),
        humidity: 40 + (s % 15).toDouble(),
        lightLux: 200 + (s % 600).toDouble(),
      );
    });
  }

  final refDb = _db.ref('/sensor_data');
  return refDb.onValue.map((event) {
    final val = event.snapshot.value;

    if (val is Map) return SensorData.fromRTDB(val as Map<dynamic, dynamic>?);
    return null;
  });
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// UserItemsNotifier (Add / Remove / Real-Time Sync for ESP)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class UserItemsNotifier extends StateNotifier<List<UserItem>> {
  final String userId;
  late final DatabaseReference _itemsRef;
  StreamSubscription<DatabaseEvent>? _sub;

  UserItemsNotifier(this.userId) : super(const []) {
    if (userId.isEmpty) return;
    _itemsRef = _db.ref('users/$userId/items');
    _listen();
  }

  /// ğŸ”„ Listen to changes in RTDB in real-time
  void _listen() {
    _sub?.cancel();
    _sub = _itemsRef.onValue.listen((event) {
      final data = event.snapshot.value;
      if (data == null || data is! Map) {
        state = [];
        return;
      }

      final items = data.entries.map((entry) {
        final value = Map<String, dynamic>.from(entry.value);
        return UserItem(
          macAddress: value['bleAddress'] ?? entry.key,
          name: value['name'] ?? 'Unknown',
          atHome: value['atHome'] ?? false,
        );
      }).toList();

      state = items;
      debugPrint('âœ… Synced ${items.length} items from RTDB.');
    }, onError: (e) {
      debugPrint('âŒ RTDB stream error: $e');
    });
  }

  /// â• Add new item (app adds, ESP later updates atHome)
  Future<void> add(String name, String bleAddress) async {
    if (userId.isEmpty) {
      debugPrint('âš ï¸ Cannot add item â€” userId empty');
      return;
    }

    final macUpper = bleAddress.trim().toUpperCase();
    if (macUpper.isEmpty || name.trim().isEmpty) return;

    try {
      await _itemsRef.child(macUpper).set({
        'name': name.trim(),
        'bleAddress': macUpper,
        'atHome': false,
      });
      debugPrint('âœ… Item added to RTDB: $name ($macUpper)');
    } catch (e, st) {
      debugPrint('âŒ Failed to add item: $e');
      debugPrintStack(stackTrace: st);
    }
  }

  /// ğŸ—‘ï¸ Remove item (both app + ESP will stop seeing it)
  Future<void> remove(String macAddress) async {
    if (userId.isEmpty) return;
    final macUpper = macAddress.trim().toUpperCase();
    if (macUpper.isEmpty) return;

    try {
      await _itemsRef.child(macUpper).remove();
      debugPrint('ğŸ—‘ï¸ Item removed: $macUpper');
    } catch (e, st) {
      debugPrint('âŒ Failed to remove item: $e');
      debugPrintStack(stackTrace: st);
    }
  }

  /// ğŸ” Manual refresh (not needed often, but available)
  Future<void> refresh() async {
    try {
      final snapshot = await _itemsRef.get();
      final data = snapshot.value;
      if (data == null || data is! Map) {
        state = [];
        return;
      }

      final items = data.entries.map((entry) {
        final value = Map<String, dynamic>.from(entry.value);
        return UserItem(
          macAddress: value['bleAddress'] ?? entry.key,
          name: value['name'] ?? 'Unknown',
          atHome: value['atHome'] ?? false,
        );
      }).toList();

      state = items;
      debugPrint('ğŸ”„ Refreshed ${items.length} items from RTDB.');
    } catch (e) {
      debugPrint('âŒ RTDB refresh failed: $e');
    }
  }

  @override
  void dispose() {
    _sub?.cancel();
    super.dispose();
  }
}

final userItemsProvider =
    StateNotifierProvider<UserItemsNotifier, List<UserItem>>((ref) {
  final user = ref.watch(authProvider);
  return UserItemsNotifier(user?.uid ?? '');
});

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TIMER PROVIDER
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class TimerState {
  final Duration total, remaining;
  final bool running, isBreak;
  const TimerState({
    required this.total,
    required this.remaining,
    required this.running,
    required this.isBreak,
  });
  String get mmss {
    final m = remaining.inMinutes.remainder(60).toString().padLeft(2, '0');
    final s = remaining.inSeconds.remainder(60).toString().padLeft(2, '0');
    return '$m:$s';
  }
}

class TimerController extends StateNotifier<TimerState> {
  final Ref ref;
  Timer? _ticker;
  Duration _studiedThisSession = Duration.zero;
  TimerController(this.ref)
      : super(
          const TimerState(
            total: Duration.zero,
            remaining: Duration.zero,
            running: false,
            isBreak: false,
          ),
        );
  void _tick() {
    final next = state.remaining - const Duration(seconds: 1);
    if (!state.isBreak) {
      _studiedThisSession += const Duration(seconds: 1);
    }
    if (next <= Duration.zero) {
      _ticker?.cancel();
      _saveStudyTime();
      // Timer finished
      state = TimerState(
        total: state.total,
        remaining: Duration.zero,
        running: false,
        isBreak: state.isBreak,
      );
      // If it was a focus session, auto-start a break
      if (!state.isBreak) {
        int breakMinutes;
        if (state.total.inMinutes <= 25) {
          breakMinutes = 5;
        } else if (state.total.inMinutes <= 45) {
          breakMinutes = 10;
        } else {
          breakMinutes = 15;
        }
        startBreak(Duration(minutes: breakMinutes));
      }
    } else {
      // Timer continues
      state = TimerState(
        total: state.total,
        remaining: next,
        running: true,
        isBreak: state.isBreak,
      );
    }
  }

  void _saveStudyTime() {
    if (_studiedThisSession > Duration.zero) {
      ref.read(studyLogProvider.notifier).addForToday(_studiedThisSession);
      _studiedThisSession = Duration.zero;
    }
  }

  void startFocus(Duration d) {
    _ticker?.cancel();
    _saveStudyTime(); // Save any previous session
    state = TimerState(total: d, remaining: d, running: true, isBreak: false);
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
  }

  void startBreak(Duration d) {
    _ticker?.cancel();
    _saveStudyTime();
    state = TimerState(total: d, remaining: d, running: true, isBreak: true);
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
  }

  void pause() {
    if (!state.running) return;
    _ticker?.cancel();
    _saveStudyTime();
    state = TimerState(
      total: state.total,
      remaining: state.remaining,
      running: false,
      isBreak: state.isBreak,
    );
  }

  void resume() {
    if (state.running || state.remaining == Duration.zero) return;
    _ticker = Timer.periodic(const Duration(seconds: 1), (_) => _tick());
    state = TimerState(
      total: state.total,
      remaining: state.remaining,
      running: true,
      isBreak: state.isBreak,
    );
  }

  void reset() {
    _ticker?.cancel();
    _saveStudyTime();
    state = const TimerState(
      total: Duration.zero,
      remaining: Duration.zero,
      running: false,
      isBreak: false,
    );
  }

  @override
  void dispose() {
    _ticker?.cancel();
    _saveStudyTime();
    super.dispose();
  }
}

final timerProvider = StateNotifierProvider<TimerController, TimerState>(
  (ref) => TimerController(ref),
);

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// APP ROOT (NEW LIGHT THEME)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class MyApp extends ConsumerWidget {
  const MyApp({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(authProvider);

    ref.listen<AppUser?>(authProvider, (previous, next) {
      if (next != null && next.uid.isNotEmpty) {
        debugPrint(
            'âœ… User logged in: ${next.uid}. Invalidating user-specific providers.');
        ref.invalidate(tasksProvider);
        ref.invalidate(studyLogProvider);
        ref.invalidate(userItemsProvider);
      }
    });
    if (kIsWeb && kUseFcm) {
      WidgetsBinding.instance.addPostFrameCallback((_) async {
        final fbm = FirebaseMessaging.instance;
        final settings = await fbm.requestPermission(
          alert: true,
          badge: true,
          sound: true,
        );
        debugPrint(
            'Post-frame permission status: ${settings.authorizationStatus}');
      });
    }
    return AnimatedSwitcher(
      duration: const Duration(milliseconds: 400),
      child: user == null
          ? const LoginScreen() // Start at Login screen
          : const _AppShell(),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// AUTH SCREENS (NEW UI)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class LoginScreen extends ConsumerWidget {
  const LoginScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    'Intellidesk',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: kPrimaryBlue,
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 48),
                  _AuthFormBody(
                    isLogin: true,
                    onSubmit: (email, password) async {
                      await ref
                          .read(authProvider.notifier)
                          .signIn(email, password);
                    },
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Don't have an account? "),
                      GestureDetector(
                        onTap: () {
                          Navigator.push(
                            context,
                            MaterialPageRoute(
                              builder: (_) => const SignUpScreen(),
                            ),
                          );
                        },
                        child: const Text(
                          'Sign up',
                          style: TextStyle(
                            color: kPrimaryBlue,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class SignUpScreen extends ConsumerWidget {
  const SignUpScreen({super.key});
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Scaffold(
      appBar: AppBar(
        // Back button
        elevation: 0,
        backgroundColor: Colors.transparent,
      ),
      body: SafeArea(
        child: Center(
          child: SingleChildScrollView(
            padding: const EdgeInsets.all(24.0),
            child: ConstrainedBox(
              constraints: const BoxConstraints(maxWidth: 400),
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  const Text(
                    'Intellidesk',
                    textAlign: TextAlign.center,
                    style: TextStyle(
                      color: kPrimaryBlue,
                      fontSize: 32,
                      fontWeight: FontWeight.bold,
                    ),
                  ),
                  const SizedBox(height: 48),
                  _AuthFormBody(
                    isLogin: false,
                    onSubmit: (email, password) async {
                      await ref
                          .read(authProvider.notifier)
                          .signUp(email, password);
                    },
                  ),
                  const SizedBox(height: 24),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      const Text("Already have an account? "),
                      GestureDetector(
                        onTap: () {
                          Navigator.pop(context); // Go back to Login
                        },
                        child: const Text(
                          'Login',
                          style: TextStyle(
                            color: kPrimaryBlue,
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          ),
        ),
      ),
    );
  }
}

class _AuthFormBody extends StatefulWidget {
  final bool isLogin;
  final Future<void> Function(String email, String password) onSubmit;
  const _AuthFormBody({required this.isLogin, required this.onSubmit});
  @override
  State<_AuthFormBody> createState() => _AuthFormBodyState();
}

class _AuthFormBodyState extends State<_AuthFormBody> {
  final _emailC = TextEditingController();
  final _passC = TextEditingController();
  final _confirmPassC = TextEditingController();
  bool _obscurePass = true;
  bool _obscureConfirm = true;
  bool _busy = false;
  String? _errorText;
  @override
  void dispose() {
    _emailC.dispose();
    _passC.dispose();
    _confirmPassC.dispose();
    super.dispose();
  }

  Future<void> _submit() async {
    if (!mounted) return;
    setState(() {
      _busy = true;
      _errorText = null;
    });
    if (!widget.isLogin && _passC.text != _confirmPassC.text) {
      setState(() {
        _errorText = "Passwords do not match";
        _busy = false;
      });
      return;
    }
    try {
      await widget.onSubmit(_emailC.text.trim(), _passC.text);
      // Auth listener will handle navigation
    } on FirebaseAuthException catch (e) {
      if (!mounted) return;
      setState(() {
        _errorText = authErrorMessage(e);
        _busy = false;
      });
    } catch (e) {
      if (!mounted) return;
      setState(() {
        _errorText = "An unknown error occurred.";
        _busy = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        // Email
        const Text("Email", style: TextStyle(fontWeight: FontWeight.w500)),
        const SizedBox(height: 8),
        TextField(
          controller: _emailC,
          keyboardType: TextInputType.emailAddress,
          decoration: const InputDecoration(
            hintText: 'Enter your email',
            contentPadding: EdgeInsets.all(15),
          ),
        ),
        const SizedBox(height: 16),
        // Password
        const Text("Password", style: TextStyle(fontWeight: FontWeight.w500)),
        const SizedBox(height: 8),
        TextField(
          controller: _passC,
          obscureText: _obscurePass,
          decoration: InputDecoration(
            hintText: 'Enter your password',
            contentPadding: const EdgeInsets.all(15),
            suffixIcon: IconButton(
              icon: Icon(
                _obscurePass ? Icons.visibility_off : Icons.visibility,
              ),
              onPressed: () => setState(() => _obscurePass = !_obscurePass),
            ),
          ),
        ),
        if (!widget.isLogin) ...[
          const SizedBox(height: 16),
          // Confirm Password
          const Text(
            "Confirm Password",
            style: TextStyle(fontWeight: FontWeight.w500),
          ),
          const SizedBox(height: 8),
          TextField(
            controller: _confirmPassC,
            obscureText: _obscureConfirm,
            decoration: InputDecoration(
              hintText: 'Confirm your password',
              contentPadding: const EdgeInsets.all(15),
              suffixIcon: IconButton(
                icon: Icon(
                  _obscureConfirm ? Icons.visibility_off : Icons.visibility,
                ),
                onPressed: () =>
                    setState(() => _obscureConfirm = !_obscureConfirm),
              ),
            ),
          ),
        ],
        const SizedBox(height: 24),
        if (_errorText != null)
          Padding(
            padding: const EdgeInsets.only(bottom: 16.0),
            child: Text(
              _errorText!,
              style: const TextStyle(
                color: Colors.red,
                fontWeight: FontWeight.w500,
              ),
            ),
          ),
        FilledButton(
          onPressed: _busy ? null : _submit,
          child: _busy
              ? const SizedBox(
                  height: 24,
                  width: 24,
                  child: CircularProgressIndicator(
                    color: Colors.white,
                    strokeWidth: 3,
                  ),
                )
              : Text(widget.isLogin ? 'Login' : 'Create Account'),
        ),
      ],
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// APP SHELL (4-TAB NAVIGATION)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _AppShell extends ConsumerStatefulWidget {
  const _AppShell();
  @override
  ConsumerState<_AppShell> createState() => _AppShellState();
}

class _AppShellState extends ConsumerState<_AppShell> {
  int _idx = 0;
  final _pages = const [_HomePage(), _FocusPage(), _ItemsPage(), _TasksPage()];

  // âœ… NEW: Add initState to run code when the widget first loads
  @override
  void initState() {
    super.initState();

    // ğŸš€ Battery Optimization Request
    // We run this *after* the first frame to safely show a dialog
    WidgetsBinding.instance.addPostFrameCallback((_) async {
      if (Platform.isAndroid) {
        // We pass 'context' and 'ref' to the helper function
        await requestBatteryOptimization(context);
      }
    });

    // ğŸš€ Notification Listener
    // We also set up the notification listener here
    WidgetsBinding.instance.addPostFrameCallback((_) {
      _setupNotificationListener(context, ref);
    });
  }

  /// âœ… NEW: Helper method to show battery optimization dialog
  Future<void> requestBatteryOptimization(BuildContext context) async {
    try {
      // Skip if already granted
      final status = await Permission.ignoreBatteryOptimizations.status;
      if (status.isGranted) {
        debugPrint("ğŸ”‹ Battery optimization already granted.");
        return;
      }

      // Get device info for specific tips
      final info = await DeviceInfoPlugin().androidInfo;
      final manufacturer = info.manufacturer.toLowerCase();

      // Guard against async context issues
      if (!context.mounted) return;

      await showDialog(
        context: context,
        builder: (ctx) => AlertDialog(
          title: const Text("Important Permission"),
          content: Text(
            "To check your Wi-Fi and send 'left item' alerts, "
            "Intellidesk needs to run in the background.\n\n"
            "Please select 'Allow' on the next screen.\n\n"
            // Tip for Samsung users
            "${manufacturer.contains('samsung') ? 'Samsung users: You may also need to go to Settings > Apps > Intellidesk > Battery > and select Unrestricted.' : ''}",
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(ctx),
              child: const Text("Later"),
            ),
            TextButton(
              onPressed: () async {
                Navigator.pop(ctx);
                // ğŸ¯ This is the built-in permission request
                await Permission.ignoreBatteryOptimizations.request();
              },
              child: const Text("Open Settings"),
            ),
          ],
        ),
      );
    } catch (e, st) {
      debugPrint("âš ï¸ Could not show battery optimization dialog: $e");
      debugPrint(st.toString());
    }
  }

  /// ğŸ§  UPGRADE 1: Smarter â€œLeft-Homeâ€ Push Notification
  void _setupNotificationListener(BuildContext context, WidgetRef ref) {
    ref.listen<AsyncValue<bool>>(leftHomeAnyProvider, (previous, next) async {
      if (next.asData?.value == true) {
        debugPrint('ğŸ“¡ Left home detected â€” comparing items in Firebaseâ€¦');

        final items = ref.read(userItemsProvider);
        final itemsLeftBehind = items.where((item) => item.atHome).toList();

        if (itemsLeftBehind.isNotEmpty) {
          // Build body text dynamically
          final count = itemsLeftBehind.length - 1;
          final itemList =
              itemsLeftBehind.take(4).map((i) => i.name).join(', ');
          final remaining = count > 3
              ? ' and ${count - 3} more'
              : (count > 0 ? ' and $count more' : '');
          final body = 'You left $itemList$remaining at home.';

          await Notifier.show(
            title: 'Forgot something?',
            body: body,
          );

          debugPrint('ğŸ”” Notification sent: $body');

          // Log to Firebase (optional)
          try {
            final user = ref.read(authProvider);
            if (user != null) {
              final alertRef = _db.ref('users/${user.uid}/alerts').push();
              await alertRef.set({
                'title': 'Forgot something?',
                'body': body,
                'timestamp': ServerValue.timestamp,
              });
            }
          } catch (e) {
            debugPrint('âš ï¸ Could not log alert: $e');
          }
        } else {
          debugPrint('âœ… All items left home with you. No alert sent.');
        }
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: IndexedStack(index: _idx, children: _pages),
      bottomNavigationBar: NavigationBar(
        selectedIndex: _idx,
        onDestinationSelected: (v) => setState(() => _idx = v),
        destinations: const [
          NavigationDestination(
            icon: Icon(Icons.home_outlined),
            selectedIcon: Icon(Icons.home),
            label: 'Home',
          ),
          NavigationDestination(
            icon: Icon(Icons.timer_outlined),
            selectedIcon: Icon(Icons.timer),
            label: 'Focus',
          ),
          NavigationDestination(
            icon: Icon(Icons.link_outlined),
            selectedIcon: Icon(Icons.link),
            label: 'Items',
          ),
          NavigationDestination(
            icon: Icon(Icons.task_alt_outlined),
            selectedIcon: Icon(Icons.task_alt),
            label: 'Tasks',
          ),
        ],
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// ğŸ§  UPGRADE 2A: Search Delegate Class
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ItemSearchDelegate extends SearchDelegate<UserItem?> {
  final WidgetRef ref;
  ItemSearchDelegate(this.ref);

  List<UserItem> get _items => ref.read(userItemsProvider);

  @override
  Widget? buildLeading(BuildContext context) => IconButton(
      icon: const Icon(Icons.arrow_back),
      onPressed: () => close(context, null));

  @override
  List<Widget>? buildActions(BuildContext context) => [
        if (query.isNotEmpty)
          IconButton(icon: const Icon(Icons.clear), onPressed: () => query = '')
      ];

  @override
  Widget buildResults(BuildContext context) {
    final results = _items
        .where((i) =>
            i.name.toLowerCase().contains(query.toLowerCase()) ||
            i.macAddress.toLowerCase().contains(query.toLowerCase()))
        .toList();
    return results.isEmpty
        ? Center(child: Text('No results for "$query"'))
        : ListView.builder(
            itemCount: results.length,
            itemBuilder: (context, index) {
              final item = results[index];
              return ListTile(
                title: Text(item.name),
                subtitle: Text(item.macAddress),
                trailing: Icon(
                  item.atHome ? Icons.home : Icons.location_off,
                  color: item.atHome ? Colors.green : Colors.redAccent,
                ),
              );
            },
          );
  }

  @override
  Widget buildSuggestions(BuildContext context) => buildResults(context);
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TAB 1: HOME (DASHBOARD) SCREEN (FIXED DESIGN)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _HomePage extends ConsumerWidget {
  const _HomePage();

  // ğŸ”¹ Helper to choose icons for items
  IconData _getIconForItem(String itemName) {
    final name = itemName.toLowerCase();
    if (name.contains('macbook') || name.contains('laptop')) {
      return Icons.laptop_chromebook;
    }
    if (name.contains('book')) return Icons.menu_book;
    if (name.contains('headphones')) return Icons.headphones;
    if (name.contains('key')) return Icons.key;
    return Icons.devices_other;
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final user = ref.watch(authProvider);

    // ğŸ§  UPGRADE 2B: Swipe-Down to Research (Smart Search)
    Future<void> refreshAll() async {
      try {
        ref.invalidate(sensorStreamProvider);
        ref.invalidate(studyLogProvider);
        await ref.read(userItemsProvider.notifier).refresh();
        ref.invalidate(tasksProvider);
        debugPrint("ğŸ”„ Manual refresh triggered successfully.");
      } catch (e) {
        debugPrint("âš ï¸ Refresh failed: $e");
      }
      await Future.delayed(const Duration(milliseconds: 300));

      // After refresh, open the item search
      if (context.mounted) {
        await showSearch<UserItem?>(
          context: context,
          delegate: ItemSearchDelegate(ref),
        );
      }
    }

    return Scaffold(
      backgroundColor: kBackgroundLight,
      appBar: AppBar(
        backgroundColor: Colors.white,
        elevation: 0,
        title: const Text(
          'Intellidesk',
          style: TextStyle(
            color: Colors.black,
            fontWeight: FontWeight.w900,
            fontSize: 22,
            letterSpacing: -0.5,
          ),
        ),
        actions: [
          // ğŸŒ€ NEW: Refresh Icon Button
          IconButton(
            tooltip: "Refresh Data",
            icon: const Icon(Icons.refresh, color: Colors.black87),
            onPressed: refreshAll,
          ),
          Padding(
            padding: const EdgeInsets.only(right: 16.0),
            child: GestureDetector(
              onTap: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(builder: (_) => const ProfileScreen()),
                );
              },
              child: CircleAvatar(
                radius: 20,
                backgroundColor: const Color(0xFFFFE5CC),
                child: const Icon(Icons.person, color: Colors.black),
              ),
            ),
          ),
        ],
      ),
      // ğŸŒ€ NEW: Wrap the main content in a RefreshIndicator
      body: RefreshIndicator(
        onRefresh: refreshAll,
        color: kPrimaryBlue,
        backgroundColor: Colors.white,
        child: ListView(
          // This physics ensures the refresh indicator works even if
          // the list content is shorter than the screen
          physics: const AlwaysScrollableScrollPhysics(),
          padding: const EdgeInsets.all(16),
          children: [
            // ğŸ”¹ Greeting
            Text(
              'Hello, ${user?.displayName ?? 'User'}!',
              style: const TextStyle(
                fontSize: 28,
                fontWeight: FontWeight.w900,
                color: Colors.black,
              ),
            ),
            const SizedBox(height: 24),

            // ğŸ”¹ Environmental Stats
            const _EnvironmentSection(),
            const SizedBox(height: 24),

            // ğŸ”¹ Dashboard (Study + Items)
            const _DashboardSection(),
            const SizedBox(height: 24),

            // ğŸ”¹ Items in Home
            _ItemsSection(getIconForItem: _getIconForItem),
          ],
        ),
      ),
    );
  }
}

class _EnvironmentSection extends ConsumerWidget {
  const _EnvironmentSection();

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final sensorData = ref.watch(sensorStreamProvider);

    final temp =
        sensorData.asData?.value?.temperature?.toStringAsFixed(0) ?? '--';
    final humidity =
        sensorData.asData?.value?.humidity?.toStringAsFixed(0) ?? '--';
    final light =
        sensorData.asData?.value?.lightLux?.toStringAsFixed(0) ?? '--';

    return SizedBox(
      height: 120,
      child: ListView(
        scrollDirection: Axis.horizontal,
        children: [
          _EnvTile(
            icon: Icons.thermostat,
            title: 'Room Temp',
            value: '$tempÂ°C',
            color: const Color(0xFFFF9500),
          ),
          const SizedBox(width: 12),
          _EnvTile(
            icon: Icons.water_drop,
            title: 'Humidity',
            value: '$humidity%',
            color: const Color(0xFF32ADE6),
          ),
          const SizedBox(width: 12),
          _EnvTile(
            icon: Icons.lightbulb,
            title: 'Light Level',
            value: '$light lx',
            color: const Color(0xFFFFCC00),
          ),
        ],
      ),
    );
  }
}

class _DashboardSection extends ConsumerWidget {
  const _DashboardSection();

  String _dayKey(DateTime date) {
    return '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final studyLog = ref.watch(studyLogProvider);
    final items = ref.watch(userItemsProvider);

    final todayStudy = studyLog[_dayKey(DateTime.now())] ?? Duration.zero;
    final hours = todayStudy.inHours;
    final minutes = todayStudy.inMinutes.remainder(60);
    final itemsAtHome = items.where((i) => i.atHome).length;

    return Row(
      children: [
        Expanded(
          child: _DashboardTile(
            icon: Icons.school,
            title: "Today's Study",
            value: '${hours}h ${minutes}m',
            color: const Color(0xFF007AFF),
          ),
        ),
        const SizedBox(width: 16),
        Expanded(
          child: _DashboardTile(
            icon: Icons.link,
            title: 'Items at Home',
            value: '$itemsAtHome items',
            color: const Color(0xFF34C759),
          ),
        ),
      ],
    );
  }
}

class _ItemsSection extends ConsumerWidget {
  final IconData Function(String) getIconForItem;
  const _ItemsSection({required this.getIconForItem});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final items = ref.watch(userItemsProvider);
    final itemsInHome = items.where((i) => i.atHome).toList();

    return Container(
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Items In Home',
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.w900,
              color: Colors.black,
            ),
          ),
          const SizedBox(height: 12),
          if (itemsInHome.isEmpty)
            const Center(
              child: Text(
                'No items at home',
                style: TextStyle(color: Colors.grey),
              ),
            )
          else
            SizedBox(
              height: 120,
              child: ListView.builder(
                scrollDirection: Axis.horizontal,
                itemCount: itemsInHome.length,
                itemBuilder: (context, index) {
                  final item = itemsInHome[index];
                  return Padding(
                    padding: const EdgeInsets.only(right: 16),
                    child: Column(
                      children: [
                        Container(
                          width: 72,
                          height: 72,
                          decoration: BoxDecoration(
                            color: Colors.grey.shade100,
                            borderRadius: BorderRadius.circular(16),
                          ),
                          child: Icon(
                            getIconForItem(item.name),
                            size: 36,
                            color: Colors.grey.shade600,
                          ),
                        ),
                        const SizedBox(height: 6),
                        Text(
                          item.name,
                          style: const TextStyle(
                            fontSize: 13,
                            fontWeight: FontWeight.w700,
                          ),
                          textAlign: TextAlign.center,
                          overflow: TextOverflow.ellipsis,
                        ),
                        const SizedBox(height: 6),
                        const Row(
                          mainAxisAlignment: MainAxisAlignment.center,
                          children: [
                            Icon(Icons.circle,
                                color: Color(0xFF34C759), size: 10),
                            SizedBox(width: 4),
                            Text(
                              'In Home',
                              style: TextStyle(
                                fontSize: 11,
                                color: Colors.grey,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  );
                },
              ),
            ),
        ],
      ),
    );
  }
}

final studyLogProvider =
    StateNotifierProvider<StudyLogController, Map<String, Duration>>((ref) {
  final user = ref.watch(authProvider);
  return StudyLogController(user?.uid ?? '');
});

class StudyLogController extends StateNotifier<Map<String, Duration>> {
  final String userId;
  final _fs = FirebaseFirestore.instance;

  StudyLogController(this.userId) : super({}) {
    if (userId.isEmpty) return;
    _listen();
  }

  /// Stream live updates from Firestore
  void _listen() {
    _fs
        .collection('users')
        .doc(userId)
        .collection('studyLog')
        .snapshots()
        .listen((snapshot) {
      final newMap = <String, Duration>{};
      for (final doc in snapshot.docs) {
        final data = doc.data();
        newMap[doc.id] = Duration(minutes: data['minutes'] ?? 0);
      }
      state = newMap;
    });
  }

  /// Add to today's total study time
  Future<void> addForToday(Duration studied) async {
    if (userId.isEmpty) return;
    final todayKey = _dayKey(DateTime.now());
    final ref = _fs
        .collection('users')
        .doc(userId)
        .collection('studyLog')
        .doc(todayKey);

    await _fs.runTransaction((tx) async {
      final snap = await tx.get(ref);
      final current = snap.exists ? (snap.data()?['minutes'] ?? 0) : 0;
      final int minutesToAdd = (studied.inSeconds / 60).ceil();
      tx.set(ref, {'minutes': current + minutesToAdd}, SetOptions(merge: true));
    });
  }

  String _dayKey(DateTime date) =>
      '${date.year}-${date.month.toString().padLeft(2, '0')}-${date.day.toString().padLeft(2, '0')}';
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// ENVIRONMENTAL TILE (Small Horizontal Card)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _EnvTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String value;
  final Color color;
  const _EnvTile({
    required this.icon,
    required this.title,
    required this.value,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      width: 128,
      margin: const EdgeInsets.only(right: 12),
      padding: const EdgeInsets.all(14),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, color: color, size: 26),
          Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: const TextStyle(
                  fontSize: 13,
                  color: Colors.grey,
                  fontWeight: FontWeight.w500,
                ),
              ),
              Text(
                value,
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.w800,
                  color: Colors.black,
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// DASHBOARD TILE (Large Square Card)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _DashboardTile extends StatelessWidget {
  final IconData icon;
  final String title;
  final String value;
  final Color color;
  const _DashboardTile({
    required this.icon,
    required this.title,
    required this.value,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(18),
      decoration: BoxDecoration(
        color: Colors.white,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withValues(alpha: 0.03),
            blurRadius: 6,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Icon(icon, size: 28, color: color),
          const SizedBox(height: 10),
          Text(
            title,
            style: const TextStyle(fontSize: 14, color: Colors.grey),
          ),
          const SizedBox(height: 4),
          Text(
            value,
            style: const TextStyle(
              fontSize: 22,
              fontWeight: FontWeight.w900,
              color: Colors.black,
            ),
          ),
        ],
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// PROFILE SCREEN (NEW)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class ProfileScreen extends ConsumerWidget {
  const ProfileScreen({super.key});

  // --- âš ï¸ FIX: HELPER METHODS MOVED OUTSIDE 'build' METHOD ---

  // --- HELPER METHOD for Password Reset ---
  void _resetPassword(WidgetRef ref) async {
    final user = ref.read(authProvider);
    final BuildContext? context = navigatorKey.currentContext;

    if (user == null || user.email.isEmpty) {
      if (context != null && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Error: Could not find user email.'),
            backgroundColor: Colors.red,
          ),
        );
      }
      return;
    }

    try {
      await FirebaseAuth.instance.sendPasswordResetEmail(email: user.email);
      if (context != null && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Password reset email sent to ${user.email}'),
            backgroundColor: Colors.green,
          ),
        );
      }
    } on FirebaseAuthException catch (e) {
      if (context != null && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.message ?? "Failed to send email"}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  // --- NEW HELPER METHOD for Changing User Name ---
  Future<void> _showChangeNameDialog(
      BuildContext dialogContext, WidgetRef ref) async {
    final TextEditingController nameController = TextEditingController();
    final user = ref.read(authProvider);
    nameController.text = user?.displayName ?? ''; // Pre-fill with current name

    return showDialog<void>(
      context: dialogContext,
      barrierDismissible: false, // User must tap button to close
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Change User Name'),
          content: SingleChildScrollView(
            child: ListBody(
              children: <Widget>[
                TextFormField(
                  controller: nameController,
                  decoration: const InputDecoration(
                    labelText: 'New User Name',
                    border: OutlineInputBorder(),
                  ),
                ),
              ],
            ),
          ),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancel'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            TextButton(
              child: const Text('Save'),
              onPressed: () async {
                final newName = nameController.text.trim();
                if (newName.isEmpty) {
                  // You can add a snackbar here for "name cannot be empty"
                  return;
                }

                final BuildContext? snackbarContext =
                    navigatorKey.currentContext;

                try {
                  // 1. Get the *actual* Firebase User
                  final firebaseUser = FirebaseAuth.instance.currentUser;
                  if (firebaseUser == null) {
                    throw Exception('User not logged in.');
                  }

                  // 2. Call the method on the Firebase User
                  await firebaseUser.updateDisplayName(newName);

                  // 3. Force a reload and invalidate the provider
                  await firebaseUser.reload();
                  ref.invalidate(authProvider);

                  if (snackbarContext != null && snackbarContext.mounted) {
                    ScaffoldMessenger.of(snackbarContext).showSnackBar(
                      const SnackBar(
                        content: Text('User name updated successfully!'),
                        backgroundColor: Colors.green,
                      ),
                    );
                  }
                  if (context.mounted) {
                    Navigator.of(context).pop(); // Close the dialog
                  }
                } on FirebaseAuthException catch (e) {
                  if (snackbarContext != null && snackbarContext.mounted) {
                    ScaffoldMessenger.of(snackbarContext).showSnackBar(
                      SnackBar(
                        content: Text('Error updating name: ${e.message}'),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                } catch (e) {
                  if (snackbarContext != null && snackbarContext.mounted) {
                    ScaffoldMessenger.of(snackbarContext).showSnackBar(
                      SnackBar(
                        content: Text('An unexpected error occurred: $e'),
                        backgroundColor: Colors.red,
                      ),
                    );
                  }
                }
              },
            ),
          ],
        );
      },
    );
  }
  // --- END HELPER METHODS ---

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    // Watch the authProvider so the UI rebuilds when display name changes
    final user = ref.watch(authProvider);

    return Scaffold(
      appBar: AppBar(title: const Text('Profile & Settings')),
      body: ListView(
        padding: const EdgeInsets.all(16.0),
        children: [
          Center(
            child: Column(
              children: [
                CircleAvatar(
                  radius: 50,
                  backgroundColor:
                      Colors.orange.shade100, // A light, warm orange
                  child: Icon(
                    Icons.person,
                    size: 48,
                    color: Colors.orange.shade700, // A darker orange
                  ),
                ),
                const SizedBox(height: 16),
                Text(
                  user?.displayName ?? 'User',
                  style: Theme.of(context)
                      .textTheme
                      .headlineSmall
                      ?.copyWith(fontWeight: FontWeight.bold),
                ),
                const SizedBox(height: 4),
                Text(
                  user?.email ?? 'No email',
                  style: Theme.of(context)
                      .textTheme
                      .titleMedium
                      ?.copyWith(color: Colors.grey.shade600),
                ),
              ],
            ),
          ),
          const SizedBox(height: 32),
          Card(
            child: Column(
              children: [
                ListTile(
                  leading: const Icon(Icons.edit_outlined),
                  title: const Text('Change User Name'),
                  subtitle: Text(user?.displayName ?? 'Not set'),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () => _showChangeNameDialog(context, ref),
                ),
                const Divider(height: 1), // Separator
                ListTile(
                  leading: const Icon(Icons.email_outlined),
                  title: const Text('Email Address'),
                  subtitle: Text(user?.email ?? 'Not set'),
                ),
                const Divider(height: 1), // Separator
                ListTile(
                  leading: const Icon(Icons.lock_reset_outlined),
                  title: const Text('Reset Password'),
                  trailing: const Icon(Icons.chevron_right),
                  onTap: () {
                    _resetPassword(ref);
                  },
                ),
              ],
            ),
          ),
          const SizedBox(height: 16),
          Card(
            child: ListTile(
              leading: const Icon(Icons.logout, color: Colors.red),
              title: const Text(
                'Sign Out',
                style: TextStyle(color: Colors.red),
              ),
              onTap: () async {
                await ref.read(authProvider.notifier).signOut();
                final navContext = navigatorKey.currentContext;
                if (navContext != null && navContext.mounted) {
                  Navigator.of(navContext).popUntil((route) => route.isFirst);
                }
              },
            ),
          ),
        ],
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TAB 2: FOCUS SCREEN (NEW TIMER UI)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _FocusPage extends ConsumerStatefulWidget {
  const _FocusPage();
  @override
  ConsumerState<_FocusPage> createState() => _FocusPageState();
}

class _FocusPageState extends ConsumerState<_FocusPage> {
  // Store the selected focus time locally
  int _focusMinutes = 25;
  void _startTimer() {
    // Re-using the EnvCheckScreen from the original app logic
    Navigator.of(context)
        .push<bool>(
      MaterialPageRoute(
        builder: (_) => EnvCheckScreen(mode: 'Focus', minutes: _focusMinutes),
      ),
    )
        .then((skipped) {
      if (skipped == true && mounted) {
        ref
            .read(timerProvider.notifier)
            .startFocus(Duration(minutes: _focusMinutes));
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    final timer = ref.watch(timerProvider);
    final timerNotifier = ref.read(timerProvider.notifier);
    final bool isRunning = timer.running;
    final bool isPaused = !timer.running && timer.remaining > Duration.zero;
    // Calculate progress for the animation
    double progress = 0.0;
    if (timer.total.inSeconds > 0) {
      progress = timer.remaining.inSeconds / timer.total.inSeconds;
    }
    final String timeDisplay =
        (timer.remaining > Duration.zero || timer.running)
            ? timer.mmss
            : '${_focusMinutes.toString().padLeft(2, '0')}:00';
    return Scaffold(
      appBar: AppBar(
        title: Text(timer.isBreak ? 'Break Time' : 'Stay Focused'),
        centerTitle: true,
      ),
      body: Center(
        child: Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            const Spacer(),
            // 1. The Simple Animated Timer
            SizedBox(
              width: 250,
              height: 250,
              child: Stack(
                fit: StackFit.expand,
                children: [
                  // Use TweenAnimation for a smooth progress animation
                  TweenAnimationBuilder<double>(
                    tween: Tween(begin: 1.0, end: progress),
                    duration: const Duration(milliseconds: 200),
                    builder: (context, value, child) {
                      return CircularProgressIndicator(
                        value: value,
                        strokeWidth: 12,
                        backgroundColor: Colors.grey.shade200,
                        strokeCap: StrokeCap.round,
                        valueColor: const AlwaysStoppedAnimation(kPrimaryBlue),
                      );
                    },
                  ),
                  Center(
                    child: Text(
                      timeDisplay,
                      style: Theme.of(context).textTheme.displayLarge?.copyWith(
                        fontWeight: FontWeight.bold,
                        color: kTextPrimaryLight,
                        fontFeatures: [const FontFeature.tabularFigures()],
                      ),
                    ),
                  ),
                ],
              ),
            ),
            const SizedBox(height: 30),
            // 2. Time selection (only show when timer is idle)
            if (!isRunning && !isPaused)
              SegmentedButton<int>(
                segments: const [
                  ButtonSegment(value: 25, label: Text('25 min')),
                  ButtonSegment(value: 45, label: Text('45 min')),
                  ButtonSegment(value: 60, label: Text('60 min')),
                ],
                selected: {_focusMinutes},
                onSelectionChanged: (newSelection) {
                  setState(() {
                    _focusMinutes = newSelection.first;
                  });
                },
              ),
            const Spacer(),
            // 3. Control Buttons
            Padding(
              padding: const EdgeInsets.only(bottom: 48.0),
              child: Row(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  // Reset Button
                  SizedBox(
                    width: 64,
                    height: 64,
                    child: IconButton(
                      iconSize: 32,
                      icon: const Icon(Icons.refresh),
                      color: Colors.black54,
                      onPressed: (timer.remaining > Duration.zero || isRunning)
                          ? () => timerNotifier.reset()
                          : null,
                    ),
                  ),
                  const SizedBox(width: 20),
                  // Main Play/Pause/Start Button
                  SizedBox(
                    width: 80,
                    height: 80,
                    child: IconButton.filled(
                      iconSize: 48,
                      style: IconButton.styleFrom(
                        backgroundColor: kPrimaryBlue,
                      ),
                      onPressed: () {
                        if (isRunning) {
                          timerNotifier.pause();
                        } else if (isPaused) {
                          timerNotifier.resume();
                        } else {
                          _startTimer();
                        }
                      },
                      icon: Icon(isRunning ? Icons.pause : Icons.play_arrow),
                    ),
                  ),
                  // Spacer for balance
                  const SizedBox(width: 20 + 64),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TAB 3: ITEMS SCREEN (NEW UI)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _ItemsPage extends ConsumerWidget {
  const _ItemsPage();
  // This is the new dialog to add an item
  void _showAddItemDialog(BuildContext context, WidgetRef ref) {
    final nameController = TextEditingController();
    final macController = TextEditingController();
    showModalBottomSheet(
      context: context,
      isScrollControlled: true, // Important for keyboard
      backgroundColor: Colors.transparent, // For custom rounded corners
      builder: (ctx) => Container(
        padding: EdgeInsets.fromLTRB(
          20,
          20,
          20,
          MediaQuery.of(ctx).viewInsets.bottom + 20,
        ),
        decoration: const BoxDecoration(
          color: Colors.white,
          borderRadius: BorderRadius.only(
            topLeft: Radius.circular(20),
            topRight: Radius.circular(20),
          ),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
            // Handle
            Center(
              child: Container(
                width: 48,
                height: 5,
                decoration: BoxDecoration(
                  color: Colors.grey.shade300,
                  borderRadius: BorderRadius.circular(10),
                ),
              ),
            ),
            const SizedBox(height: 20),
            Text(
              'Add New Item',
              textAlign: TextAlign.center,
              style: Theme.of(
                context,
              ).textTheme.headlineSmall?.copyWith(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 24),
            const Text(
              "Item Name",
              style: TextStyle(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: nameController,
              decoration: const InputDecoration(hintText: 'e.g., My Backpack'),
            ),
            const SizedBox(height: 16),
            const Text(
              "Bluetooth MAC Address",
              style: TextStyle(fontWeight: FontWeight.w500),
            ),
            const SizedBox(height: 8),
            TextField(
              controller: macController,
              decoration: const InputDecoration(hintText: 'AA:BB:CC:DD:EE:FF'),
            ),
            const SizedBox(height: 24),
            FilledButton(
              onPressed: () {
                final name = nameController.text.trim();
                final mac = macController.text.trim().toUpperCase();
                if (name.isNotEmpty && mac.isNotEmpty) {
                  ref.read(userItemsProvider.notifier).add(name, mac);
                  Navigator.pop(ctx);
                  ScaffoldMessenger.of(
                    context,
                  ).showSnackBar(SnackBar(content: Text('$name added!')));
                }
              },
              child: const Text('Save Item'),
            ),
          ],
        ),
      ),
    );
  }

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final items = ref.watch(userItemsProvider);
    return Scaffold(
      appBar: AppBar(title: const Text('My Items')),
      body: items.isEmpty
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.bluetooth_searching,
                    size: 80,
                    color: Colors.grey.shade400,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No Items Found',
                    style: Theme.of(context).textTheme.headlineSmall,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    "Tap the '+' button to add your first item.",
                    style: Theme.of(context).textTheme.bodyLarge,
                  ),
                ],
              ),
            )
          : ListView.builder(
              padding: const EdgeInsets.all(16),
              itemCount: items.length,
              itemBuilder: (context, index) {
                final item = items[index];
                return _ItemTile(item: item);
              },
            ),
      floatingActionButton: FloatingActionButton(
        onPressed: () => _showAddItemDialog(context, ref),
        child: const Icon(Icons.add),
      ),
    );
  }
}

/// Helper for the Items Page
class _ItemTile extends ConsumerWidget {
  final UserItem item;
  const _ItemTile({required this.item, super.key});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final bool atHome = item.atHome;
    final Color statusColor =
        atHome ? const Color(0xFF34C759) : const Color(0xFF8E8E93);
    final Color statusBgColor =
        atHome ? const Color(0x1A34C759) : const Color(0x1A8E8E93);
    final IconData statusIcon =
        atHome ? Icons.check_circle : Icons.remove_circle_outline;

    return Card(
      margin: const EdgeInsets.symmetric(vertical: 6.0),
      shape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16),
        side: BorderSide(color: Colors.grey.shade200, width: 1),
      ),
      child: Padding(
        padding: const EdgeInsets.all(16.0),
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.center,
          children: [
            Container(
              width: 48,
              height: 48,
              decoration: BoxDecoration(
                color: statusBgColor,
                shape: BoxShape.circle,
              ),
              child: Icon(statusIcon, color: statusColor, size: 28),
            ),
            const SizedBox(width: 16),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    item.name,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                      color: Colors.black,
                    ),
                  ),
                  Text(
                    item.macAddress,
                    style: const TextStyle(
                      color: Colors.grey,
                      fontSize: 14,
                    ),
                  ),
                ],
              ),
            ),
            Column(
              mainAxisSize: MainAxisSize.min,
              crossAxisAlignment: CrossAxisAlignment.end,
              children: [
                Text(
                  atHome ? 'At Home' : 'Away',
                  style: TextStyle(
                    color: statusColor,
                    fontWeight: FontWeight.w600,
                    fontSize: 14,
                  ),
                ),
                IconButton(
                  icon: const Icon(Icons.delete_outline, color: Colors.red),
                  tooltip: 'Remove Item',
                  onPressed: () async {
                    final confirm = await showDialog<bool>(
                      context: context,
                      builder: (ctx) => AlertDialog(
                        title: const Text('Remove Item?'),
                        content: Text('Do you want to remove "${item.name}"?'),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.pop(ctx, false),
                            child: const Text('Cancel'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.pop(ctx, true),
                            child: const Text(
                              'Remove',
                              style: TextStyle(color: Colors.red),
                            ),
                          ),
                        ],
                      ),
                    );
                    if (confirm == true) {
                      await ref
                          .read(userItemsProvider.notifier)
                          .remove(item.macAddress);
                    }
                  },
                ),
              ],
            ),
          ],
        ),
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TAB 4: TASKS (TO-DO) SCREEN (FINAL CLEAN VERSION)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _TasksPage extends ConsumerStatefulWidget {
  const _TasksPage({super.key});

  @override
  ConsumerState<_TasksPage> createState() => _TasksPageState();
}

class _TasksPageState extends ConsumerState<_TasksPage> {
  final _taskController = TextEditingController();

  @override
  void dispose() {
    _taskController.dispose();
    super.dispose();
  }

  void _addTask() {
    final title = _taskController.text.trim();
    if (title.isEmpty) return;
    final user = ref.read(authProvider);
    if (user == null) return;

    ref.read(tasksProvider.notifier).add(title);
    _taskController.clear();
    if (mounted) FocusScope.of(context).unfocus();
  }

  Widget _buildAddTaskBar() {
    return Container(
      padding: EdgeInsets.fromLTRB(
        16,
        8,
        16,
        MediaQuery.of(context).viewInsets.bottom + 16,
      ),
      decoration: BoxDecoration(
        color: Theme.of(context).cardColor,
        border: Border(top: BorderSide(color: Colors.grey.shade200)),
      ),
      child: Row(
        children: [
          Expanded(
            child: TextField(
              controller: _taskController,
              decoration: InputDecoration(
                hintText: 'Add a new task...',
                border: OutlineInputBorder(
                  borderRadius: BorderRadius.circular(12.0),
                ),
                contentPadding:
                    const EdgeInsets.symmetric(horizontal: 16, vertical: 14),
              ),
              onSubmitted: (_) => _addTask(),
            ),
          ),
          const SizedBox(width: 8),
          IconButton(
            icon: const Icon(Icons.add),
            style: IconButton.styleFrom(
              backgroundColor: kPrimaryBlue,
              foregroundColor: Colors.white,
            ),
            onPressed: _addTask,
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    final tasks = ref.watch(tasksProvider);
    final pendingTasks = tasks.where((t) => !t.done).toList();
    final completedTasks = tasks.where((t) => t.done).toList();

    return Scaffold(
      appBar: AppBar(
        title: const Text(
          'My Tasks',
          style: TextStyle(
            fontFamily: 'Lexend',
            color: Colors.black,
            fontSize: 24,
            fontWeight: FontWeight.bold,
          ),
        ),
        centerTitle: true,
        backgroundColor: Colors.white,
        elevation: 0,
      ),
      body: Column(
        children: [
          Expanded(
            child: ListView(
              padding: const EdgeInsets.all(16),
              children: [
                _buildSection(context, 'To-Do', pendingTasks),
                const SizedBox(height: 24),
                if (completedTasks.isNotEmpty)
                  _buildSection(context, 'Completed', completedTasks),
              ],
            ),
          ),
          _buildAddTaskBar(),
        ],
      ),
    );
  }

  Widget _buildSection(
      BuildContext context, String title, List<Task> tasksList) {
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text(title,
            style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 20,
                fontFamily: 'Lexend')),
        const SizedBox(height: 8),
        if (tasksList.isEmpty)
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Text(
              title == 'To-Do'
                  ? 'Add a task to get started!'
                  : 'No completed tasks yet ğŸ‰',
              style: const TextStyle(color: Colors.grey, fontSize: 15),
            ),
          )
        else
          for (final t in tasksList) _TaskTile(task: t),
      ],
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// INDIVIDUAL TASK TILE
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class _TaskTile extends ConsumerWidget {
  final Task task;
  const _TaskTile({required this.task});

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    return Dismissible(
      key: ValueKey(task.id),
      background: Container(color: Colors.redAccent),
      onDismissed: (_) {
        // âœ… FIX: Use 'remove' to match the controller
        ref.read(tasksProvider.notifier).remove(task.id);
      },
      child: Card(
        margin: const EdgeInsets.symmetric(vertical: 4),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        elevation: 0.5,
        child: ListTile(
          leading: Checkbox(
            value: task.done,
            onChanged: (_) => ref.read(tasksProvider.notifier).toggle(task.id),
            activeColor: kPrimaryBlue,
            shape:
                RoundedRectangleBorder(borderRadius: BorderRadius.circular(6)),
          ),
          title: GestureDetector(
            onLongPress: () async {
              final controller = TextEditingController(text: task.title);
              final newTitle = await showDialog<String>(
                context: context,
                builder: (_) => AlertDialog(
                  title: const Text('Edit Task'),
                  content: TextField(controller: controller),
                  actions: [
                    TextButton(
                        onPressed: () => Navigator.pop(context),
                        child: const Text('Cancel')),
                    TextButton(
                        onPressed: () =>
                            Navigator.pop(context, controller.text.trim()),
                        child: const Text('Save')),
                  ],
                ),
              );
              if (newTitle != null && newTitle.isNotEmpty) {
                // âœ… FIX: Use 'edit' to match the controller
                ref.read(tasksProvider.notifier).edit(task.id, newTitle);
              }
            },
            child: Text(
              task.title,
              style: TextStyle(
                decoration: task.done
                    ? TextDecoration.lineThrough
                    : TextDecoration.none,
                color: task.done ? Colors.grey.shade600 : kTextPrimaryLight,
                fontWeight: task.done ? FontWeight.normal : FontWeight.w500,
                fontSize: 16,
              ),
            ),
          ),
        ),
      ),
    );
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// TASK CONTROLLER (CRUD LOGIC)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
final tasksProvider = StateNotifierProvider<TaskController, List<Task>>((ref) {
  final user = ref.watch(authProvider);
  return TaskController(user?.uid ?? '');
});

class TaskController extends StateNotifier<List<Task>> {
  final String uid;
  TaskController(this.uid) : super([]) {
    // âœ… FIX: Only listen if the uid is not empty
    if (uid.isNotEmpty) {
      _listenTasks();
    }
  }

  final _fs = FirebaseFirestore.instance;
  StreamSubscription? _taskSubscription;

  // âœ… CLEAN VERSION with automatic cleanup
  void _listenTasks() {
    _taskSubscription?.cancel(); // Cancel any old listener
    final todayKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final userTasksRef = _fs.collection('users').doc(uid).collection('tasks');

    // ğŸ§¹ Optional cleanup: remove outdated daily task docs
    userTasksRef.get().then((snap) async {
      for (final doc in snap.docs) {
        if (doc.id != todayKey) {
          // This deletes the old day's document.
          // Note: This is a shallow delete. For a deep delete of subcollections,
          // you'd need a cloud function, but this structure is fine.
          await doc.reference.delete();
          debugPrint('ğŸ§¹ Deleted old task doc: ${doc.id}');
        }
      }
    });

    // ğŸ‘‡ Listen only to today's subcollection
    _taskSubscription = userTasksRef
        .doc(todayKey)
        .collection('tasks')
        .snapshots()
        .listen((snap) {
      final list = snap.docs.map((d) => Task.fromFirestore(d)).toList();

      // â¬‡ï¸â¬‡ï¸ SAFER SORTING â¬‡ï¸â¬‡ï¸
      list.sort((a, b) {
        // Put tasks without a creation date at the very end
        if (b.createdAt == null) return -1;
        if (a.createdAt == null) return 1;
        return b.createdAt!.compareTo(a.createdAt!);
      });
      // â¬†ï¸â¬†ï¸ END OF SORTING â¬†ï¸â¬†ï¸

      state = list;
    });
  }

  // â• Add new task
  Future<void> add(String title) async {
    if (uid.isEmpty) return;
    final todayKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final ref = _fs
        .collection('users')
        .doc(uid)
        .collection('tasks')
        .doc(todayKey)
        .collection('tasks')
        .doc();

    final task = Task(
      id: ref.id,
      title: title,
      createdAt: DateTime.now(), // âœ… Add createdAt on creation
    );

    // Use the .toFirestore() method
    await ref.set(task.toFirestore());
  }

  // ğŸ”„ Toggle done/undone
  Future<void> toggle(String id) async {
    if (uid.isEmpty) return;
    final todayKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final ref = _fs
        .collection('users')
        .doc(uid)
        .collection('tasks')
        .doc(todayKey)
        .collection('tasks')
        .doc(id);

    try {
      final current = state.firstWhere((t) => t.id == id);
      await ref.update({'done': !current.done});
    } catch (e) {
      debugPrint("âš ï¸ Could not find task to toggle: $e");
    }
  }

  // ğŸ—‘ï¸ Remove task
  Future<void> remove(String id) async {
    if (uid.isEmpty) return;
    final todayKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    final ref = _fs
        .collection('users')
        .doc(uid)
        .collection('tasks')
        .doc(todayKey)
        .collection('tasks')
        .doc(id);
    await ref.delete();
  }

  // âœï¸ Edit title
  Future<void> edit(String id, String newTitle) async {
    if (uid.isEmpty) return;
    final todayKey = DateFormat('yyyy-MM-dd').format(DateTime.now());
    await _fs
        .collection('users')
        .doc(uid)
        .collection('tasks')
        .doc(todayKey)
        .collection('tasks')
        .doc(id)
        .update({'title': newTitle});
  }

  @override
  void dispose() {
    _taskSubscription?.cancel(); // âœ… Clean up the listener
    super.dispose();
  }
}

/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
/// ENV CHECK (Kept from original)
/// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
class EnvCheckScreen extends ConsumerStatefulWidget {
  final String mode; // "Focus" or "Break"
  final int minutes;
  const EnvCheckScreen({super.key, required this.mode, required this.minutes});
  @override
  ConsumerState<EnvCheckScreen> createState() => _EnvCheckScreenState();
}

class _EnvCheckScreenState extends ConsumerState<EnvCheckScreen> {
  // Comfort ranges
  static const double _tMin = 23.0, _tMax = 27.0; // Â°C
  static const double _hMin = 40.0, _hMax = 60.0; // %
  static const double _luxMin = 300.0, _luxMax = 750.0; // lux
  String _tipForTemp(double? t) {
    if (t == null) return 'Waiting for temperatureâ€¦';
    if (t < _tMin) return 'Feels cold. Close a window?';
    if (t > _tMax) return 'Feels warm. Open a window?';
    return 'Great temperature for studying.';
  }

  String _tipForHum(double? h) {
    if (h == null) return 'Waiting for humidityâ€¦';
    if (h < _hMin) return 'Air is dry. A humidifier can help.';
    if (h > _hMax) return 'Air is humid. Ventilation can help.';
    return 'Comfortable humidity.';
  }

  String _tipForLight(double? lux) {
    if (lux == null) return 'Waiting for light sensorâ€¦';
    if (lux < _luxMin) return 'Too dim. Turn on a light.';
    if (lux > _luxMax) return 'Too bright. Reduce glare.';
    return 'Ideal lighting for studying.';
  }

  @override
  Widget build(BuildContext context) {
    final sensor = ref.watch(sensorStreamProvider);
    final temp = sensor.asData?.value?.temperature;
    final hum = sensor.asData?.value?.humidity;
    final light = sensor.asData?.value?.lightLux;
    final tempOk = temp != null && temp >= _tMin && temp <= _tMax;
    final humOk = hum != null && hum >= _hMin && hum <= _hMax;
    final lightOk = light != null && light >= _luxMin && light <= _luxMax;
    return Scaffold(
      appBar: AppBar(title: Text('${widget.mode} Check'), centerTitle: true),
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Column(
            children: [
              Text(
                'Ready for your ${widget.minutes} minute session?',
                style: Theme.of(context).textTheme.headlineSmall,
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 16),
              const Text(
                'Here\'s a check of your study environment:',
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 24),
              // Status rows
              Card(
                child: Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Column(
                    children: [
                      _CheckRow(
                        title: temp == null
                            ? 'Temperature'
                            : 'Temperature ${temp.toStringAsFixed(1)}Â°C',
                        ok: tempOk,
                        waiting: temp == null,
                        tip: _tipForTemp(temp),
                      ),
                      const Divider(height: 24),
                      _CheckRow(
                        title: hum == null
                            ? 'Humidity'
                            : 'Humidity ${hum.toStringAsFixed(0)}%',
                        ok: humOk,
                        waiting: hum == null,
                        tip: _tipForHum(hum),
                      ),
                      const Divider(height: 24),
                      _CheckRow(
                        title: light == null
                            ? 'Light Intensity'
                            : 'Light ${light.toStringAsFixed(0)} lux',
                        ok: lightOk,
                        waiting: light == null,
                        tip: _tipForLight(light),
                      ),
                    ],
                  ),
                ),
              ),
              const Spacer(),
              // CTA buttons
              FilledButton(
                onPressed: () => Navigator.pop(context, true), // Start
                child: Text('Start ${widget.mode} Session'),
              ),
              const SizedBox(height: 12),
              TextButton(
                onPressed: () => Navigator.pop(context, false), // Cancel
                child: const Text('Cancel'),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

/// Helper for EnvCheckScreen
class _CheckRow extends StatelessWidget {
  final String title;
  final bool ok;
  final bool waiting;
  final String tip;
  const _CheckRow({
    required this.title,
    required this.ok,
    required this.waiting,
    required this.tip,
  });
  @override
  Widget build(BuildContext context) {
    final Color color;
    final IconData icon;
    if (waiting) {
      color = Colors.grey;
      icon = Icons.more_horiz;
    } else if (ok) {
      color = Colors.green;
      icon = Icons.check_circle;
    } else {
      color = Colors.orange;
      icon = Icons.error_outline;
    }
    return Row(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Icon(icon, color: color, size: 28),
        const SizedBox(width: 16),
        Expanded(
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              Text(
                title,
                style: Theme.of(
                  context,
                ).textTheme.titleMedium?.copyWith(fontWeight: FontWeight.bold),
              ),
              const SizedBox(height: 4),
              Text(tip, style: Theme.of(context).textTheme.bodyMedium),
            ],
          ),
        ),
      ],
    );
  }
}
